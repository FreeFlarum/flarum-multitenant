{"version":3,"file":"forum.js","mappings":"MACA,IAAIA,EAAsB,CCA1BA,EAAyBC,IACxB,IAAIC,EAASD,GAAUA,EAAOE,WAC7B,IAAOF,EAAiB,QACxB,IAAM,EAEP,OADAD,EAAoBI,EAAEF,EAAQ,CAAEG,EAAGH,IAC5BA,GCLRF,EAAwB,CAACM,EAASC,KACjC,IAAI,IAAIC,KAAOD,EACXP,EAAoBS,EAAEF,EAAYC,KAASR,EAAoBS,EAAEH,EAASE,IAC5EE,OAAOC,eAAeL,EAASE,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3ER,EAAwB,CAACc,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFf,EAAyBM,IACH,oBAAXa,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeL,EAASa,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeL,EAAS,aAAc,CAAEe,OAAO,M,+BCLvD,MAAM,EAA+BC,OAAOC,KAAKC,OAAO,c,aCAxD,MAAM,EAA+BF,OAAOC,KAAKC,OAAO,iBCAlD,EAA+BF,OAAOC,KAAKC,OAAO,+B,aCAxD,MAAM,EAA+BF,OAAOC,KAAKC,OAAO,gC,aCAxD,MAAM,EAA+BF,OAAOC,KAAKC,OAAO,uB,aCS3CC,EAAO,gCCTL,SAASC,EAAgBjB,EAAGkB,GAMzC,OALAD,EAAkBhB,OAAOkB,gBAAkB,SAAyBnB,EAAGkB,GAErE,OADAlB,EAAEoB,UAAYF,EACPlB,GAGFiB,EAAgBjB,EAAGkB,GCLb,SAASG,EAAeC,EAAUC,GAC/CD,EAASf,UAAYN,OAAOuB,OAAOD,EAAWhB,WAC9Ce,EAASf,UAAUkB,YAAcH,EACjCH,EAAeG,EAAUC,GCJ3B,MAAM,EAA+BV,OAAOC,KAAKC,OAAO,oB,aCAxD,MAAM,EAA+BF,OAAOC,KAAKC,OAAO,4B,aCAxD,MAAM,EAA+BF,OAAOC,KAAKC,OAAO,uB,aCYnCW,EAAAA,SAAAA,G,oFACpBC,OAAA,SAAOC,GACN,YAAMD,OAAN,UAAaC,I,EAGdC,KAAA,WACC,IAAQC,EAAYC,KAAKC,MAAjBF,QACR,OACC,UAAMG,UAAU,YAAYC,QAAS,kBAAMJ,GAASA,OAClDK,GAAAA,CAAK,cAAaL,IAAY,SAAW,O,EATzBJ,CAAkBU,KCEjCC,EAAIC,IAAIC,WAAWC,MAAMC,KAAKH,IAAIC,YAEnBG,EAAAA,SAAAA,G,oFACpBf,OAAA,SAAOC,GACN,YAAMD,OAAN,UAAaC,I,EAGdC,KAAA,WACC,MAAyCE,KAAKC,MAAtCW,EAAR,EAAQA,YAAaC,EAArB,EAAqBA,gBAErB,OAKC,SAAKX,UAAU,4BACd,WACCA,UAAU,wBACVY,KAAK,WACLC,KAAMF,IAAoB,OAAS,WACnCG,YAAaC,GAAAA,CAAYX,EAAE,2CAC3BY,KAAMN,EAAYO,SAClBC,SAAUR,EAAYS,UAEvB,EAAC1B,EAAD,CAAWI,QAASc,M,EAtBHF,CAA2BN,KChBjC,SAASiB,IAetB,OAdAA,EAAWpD,OAAOqD,QAAU,SAAUC,GACpC,IAAK,IAAIC,EAAI,EAAGA,EAAIC,UAAUC,OAAQF,IAAK,CACzC,IAAIG,EAASF,UAAUD,GAEvB,IAAK,IAAIzD,KAAO4D,EACV1D,OAAOM,UAAUC,eAAeC,KAAKkD,EAAQ5D,KAC/CwD,EAAOxD,GAAO4D,EAAO5D,IAK3B,OAAOwD,GAGFF,EAASO,MAAM7B,KAAM0B,W,ICXjBI,EAAS,qBAEpBC,EAAAA,KAAAA,MAAAA,EAAAA,IAWWC,EAAUC,SAAAA,GAAD,OACpBA,EAAAA,MAAa,qBAAYC,EAAAA,EAAOC,EAAPD,GAAeA,EAAAA,EAAOC,EAA/CF,MAEWG,EAAyBC,SAAAA,GACpC,IAAMC,EAAN,GACIC,EAAJ,EAKA,OAJAF,EAAAA,SAAqBG,SAAAA,GACnBF,EAAAA,GAAAA,EACAC,GAAAA,KAEF,GCvBWE,ECJE,CACb,EAAG,CACD,GADC,GAED,GAHW,IAKb,EAAG,CACD,GADC,GAED,GAPW,IASb,EAAG,CACD,GADC,GAED,GAFC,GAGD,GAZW,IAcb,EAAG,CACD,GADC,GAED,GAFC,GAGD,GAHC,GAID,GAlBW,IAoBb,EAAG,CACD,GADC,GAED,GAFC,KDTQC,EAAc,mCACdC,EAAY,mCAEZC,EAAY,oBACZC,EAAqB,qBACrBC,EAAY,oBACZC,EAAqB,qBACrBC,EAAY,iBACZC,EAAY,iBACZC,EAAiB,uBACjBC,EAAY,QACZC,GAAiB,wBACjBC,EAAU,CAAEC,WAAY,6BELrC,a,yCAqBEC,MAAAA,SAAAA,GAAK,IAAGpC,EAAH,EAAGA,SACAc,EAAO,UACR,gCADwB,GAExB,6BAFL,IAKMuB,EAAkB,iBAAxB,GACI,OAAGxB,EAAP,I,EAGFyB,wBAAAA,SAAuB,GAIrB,IAHA,IAAMxB,EAAN,GACMyB,EAAN,8CAESjC,EAAT,EAAgBA,GAAKkC,KAAAA,IAASxC,EAAAA,OAA9B,GAAoDM,GAApD,EACE,IAAK,IAAImC,EAAInC,EAAb,EAAoBmC,GAAKnC,EAAzB,KACMmC,GAAKzC,EAAT,QAD8ByC,GAAhC,EAAwC,CAItC,IAAMC,EAAQ1C,EAAAA,MAAAA,GAAkB,KAAhC,KACM2C,EAAaJ,EAAAA,KAAnB,GACA,SAAII,EAAoB,CACtB,IAAMC,EAAM,+BAA+B,CACzCC,SAASF,EAAD,GADiC,IAEzCE,SAASF,EAAD,GAFiC,IAGzCE,SAASF,EAAD,GAHV,MAKA,MAAIC,GACF9B,EAAAA,KAAa,CACXgC,QADW,OAEXJ,MAAAA,EACApC,EAAAA,EACAmC,EAAAA,EACAM,UAAWJ,EALA,GAMXK,KAAMJ,EANK,KAOXK,MAAOL,EAPI,MAQXM,IAAKN,EAAIM,OAMnB,U,EAIFC,2BAAAA,SAA0B,GAMpB,IANoB,WAClBrC,EAAN,GACMsC,EAAN,YACMC,EAAUC,SAAAA,GAAD,OACbd,KAAAA,IAASc,EAAAA,KADX,IAGShD,EAAT,EAAgBA,GAAKkC,KAAAA,IAASxC,EAAAA,OAA9B,GAAoDM,GAApD,EACE,IAD0D,eACjDmC,GACP,GAAIA,GAAKzC,EAAT,OACE,cAEF,IAAM0C,EAAQ1C,EAAAA,MAAAA,GAAkB,KAAhC,KACA,GAAIoD,EAAAA,KAAJ,GAAsC,CACpC,IAAMG,EAAN,GACMC,EAAQd,EAAd,OAYA,GAXsBpB,EAAtB,GACAmC,SAAsB,gBAAC,EAAD,YACdb,EAAM,4BAA+B,CACzCC,SAASH,EAAAA,MAAAA,EAAD,GADiC,IAEzCG,SAASH,EAAAA,MAAAA,EAAD,GAFiC,IAGzCG,SAASH,EAAAA,MAAD,GAHV,MAKA,MAAIE,GACFW,EAAAA,KAAAA,MAGAA,EAAAA,OAAJ,EAA2B,CAUzB,IAAIG,EAAgBH,EAApB,GACII,EAAcN,EAAOE,EAAzB,IACAA,EAAAA,MAAAA,GAAAA,SAA6BD,SAAAA,GAC3B,IAAMM,EAAWP,EAAjB,GACIO,EAAJ,IACEF,EAAAA,EACAC,EAAAA,MAGJ7C,EAAAA,KAAa,CACXgC,QADW,OAEXJ,MAAAA,EACApC,EAAAA,EACAmC,EAAAA,EACAM,UALW,GAMXC,KAAMU,EANK,KAOXT,MAAOS,EAPI,MAQXR,IAAKQ,EAAcR,SA9ClBT,EAAInC,EAAb,EAAoBmC,GAAKnC,EAAzB,GAAwC,YAA/BmC,GAAuBA,GAAhC,GAoDF,U,EAYFoB,YAAAA,SAAW,GACL,OAAG,UAAgBzB,SAAAA,GAGf,IAFN,IAAI0B,GAAJ,EACMC,EAAgBjD,EAAtB,OACShE,EAAT,EAAgBA,EAAhB,EAAmCA,GAAnC,EAA2C,CACzC,IAAMkH,EAAalD,EAAnB,GACA,GAAIsB,IAAJ,GACM4B,EAAAA,GAAgB5B,EAAhB4B,GAA2BA,EAAAA,GAAgB5B,EAA/C,EAAwD,CACtD0B,GAAAA,EACA,OAIN,a,EAeJG,0BAAAA,SAAyB,GACvB,GAAIC,EAAAA,GAAAA,IAAoBA,EAAAA,IAAxB,EACE,YAKF,IAHA,IAAIC,EAAJ,EACIC,EAAJ,EACIC,EAAJ,EACSvH,EAAJ,EAAWwH,EAAOJ,EAAvB,OAAwCpH,EAAxC,EAAkDA,GAAlD,EAA0D,CACxD,IAAMyH,EAAML,EAAZ,GACA,GAAKK,EAAAA,IAAYA,EF9LM,KE8LkBA,EF/LlB,KEgMrB,YAEEA,EAAJ,KACEH,GAAAA,GAEEG,EAAJ,KACEJ,GAAAA,GAEEI,GAAJ,IACEF,GAAAA,GAGA,OAAAD,GAAAA,GAAAA,IAAeD,GAAgBE,GAAnC,EACE,KAEK,iBAAP,I,EAIFG,YAAAA,SAAW,GAOT,IALA,IAAMC,EAA2C,CAC/C,CAACP,EAAD,GAAcA,EAAAA,MAAAA,EADiC,IAE/C,CAACA,EAAD,GAAcA,EAAAA,MAAAA,EAFiC,KAI3CQ,EAA2BD,EAAjC,OACShC,EAAT,EAAgBA,EAAhB,EAA8CA,GAA9C,EAAsD,CACpD,MAAkBgC,EAAlB,GAAM,EAAN,KAAM,EAAN,KACA,GF3NuB,KE2NnBE,GAAsBC,GF5NH,KE4NuB,CAC5C,IAAMC,EAAK,2BAAX,GACA,aAAIA,EACK,CACL7B,KADK,EAELC,MAAO4B,EAFF,MAGL3B,IAAK2B,EAAG3B,KAQZ,MAKA,IAAC,IAAI4B,EAAT,EAAgBA,EAAhB,EAA8CA,GAA9C,EAAsD,CACpD,MAAkBL,EAAlB,GAAM,EAAN,KAAM,EAAN,KACMI,EAAK,2BAAX,GACA,SAAIA,EACF,MAAO,CACL7B,KAAM,wBADD,GAELC,MAAO4B,EAFF,MAGL3B,IAAK2B,EAAG3B,KAId,a,EAGF6B,sBAAAA,SAAqB,GAEf,IADA,IAAEC,EAAO,GAAWd,EAAAA,QAAxB,WACS5D,EAAT,EAAgBA,EAAI0E,EAApB,OAAiC1E,GAAjC,EAAyC,CACvC,IAAM2E,EAAOD,EAAb,GACM9B,EAAM+B,EAAZ,GACMhC,EAAQgC,EAAd,GACA,GAAI/B,GAAAA,GAAYA,GAAZA,IAAyBD,GAAzBC,GAAuCD,GAA3C,GACE,MAAO,CACLC,IAAAA,EACAD,MAAAA,GAIN,a,EAGFiC,mBAAAA,SAAkB,GAChB,OAAIlC,EAAJ,GACE,EAEEA,EAAJ,GAESA,EAAP,KAGKA,EAAP,K,EAtQJ,GClBImC,EAAW,CACbzI,EAAG,CAAC,IADS,KAEb0I,EAAG,CAFU,KAGbC,EAAG,CAAC,IAAK,IAAK,IAHD,KAIbC,EAAG,CAJU,KAKbC,EAAG,CAAC,IALS,KAMbjF,EAAG,CAAC,IAAK,IANI,KAObkF,EAAG,CAAC,IAAK,IAPI,KAQb1I,EAAG,CARU,KASb2I,EAAG,CAAC,IATS,KAUbtG,EAAG,CAAC,IAVS,KAWbuG,EAAG,CAXU,KAYbC,EAAG,CAAC,MCZFC,EAAW,CACbC,SAAU,CACRC,YADQ,cAERC,WAFQ,aAGRC,aAHQ,eAIRC,eAJQ,iBAKRC,UALQ,YAMRC,YANQ,cAORC,MAPQ,QAQRC,OARQ,SASRC,WATQ,aAURC,OAVQ,SAWRC,gBAXQ,kBAYRC,aAZQ,eAaRC,kBAbQ,oBAcRC,YAdQ,cAeRC,WAAY,cAEdC,YAAa,CACXC,KADW,OAEXC,aAFW,eAGXC,aAHW,eAIXC,eAJW,iBAKXb,MALW,QAMXD,YANW,cAOXe,gBAPW,kBAQXhB,UARW,YASXiB,SATW,WAUXC,sBAVW,wBAWXC,YAXW,cAYXC,SAZW,WAaXC,OAAQ,UAEVC,eAAgB,CACdC,SADc,WAEdC,OAFc,SAGdC,QAHc,UAIdC,OAJc,SAKdC,QALc,UAMdC,KANc,OAOdC,MAPc,QAQd7E,IARc,MASd8E,KATc,OAUd/E,MAVc,QAWdgF,OAXc,SAYdjF,KAZc,OAadkF,MAbc,QAcdC,UAAW,cCoFf,EAAe,IArHf,WAiBE5J,SAAAA,IAhBA,iBAEA,iBAEA,gBAAgC,CAC9BqI,WAAY,IAGd,2BAEI/H,KAAK,aAAT,EAEA,eAEIA,KAAK,gBAAT,GAGE,6B,2BAGFuJ,WAAAA,SAAWC,QAAD,IAACA,IAAAA,EAAD,IACJA,EAAJ,YACE,eAAiBA,EAAjB,WAGEA,EAAJ,aACE,gBAAkBA,EAAlB,WAEA,8BAGEA,EAAJ,cACE,qBAAqBA,EAArB,cAGEA,EAAJ,SACE,YAAcA,EAAd,S,EAIJC,gBAAAA,SAAe,GACT,iCAAJ,GAGE,MAAM,UAAN,gDAFA,qB,EAMJC,wBAAAA,SAAuB,GACrB,IAAIC,GAAJ,EAaA,OAZAzL,OAAAA,KAAAA,GAAAA,SAAsC6C,SAAAA,GACpC,GAAIA,KAAJ,EAA0B,CACxB,IAAM6I,EAAN,EACA1L,OAAAA,KAAY6I,EAAZ7I,IAAAA,SAAuDF,SAAAA,GAC/CA,KAAO6L,EAAb,KACEF,GAAAA,WAIJA,GAAAA,KAGJ,G,EAGFG,sBAAAA,WAAqB,WACbC,EAAN,GACA7L,OAAAA,KAAY,KAAZA,YAAAA,SAAsC4C,SAAAA,GACpCiJ,EAAAA,GAA2B,sBAA3BA,MAEF,2B,EAGFC,oBAAAA,SAAmB,GACjB,IAAMC,EAAO,gBAAb,GACA,kBAAInJ,EAAuB,CACzB,IAAMoJ,EAAN,GAaA,OAXAD,EAAAA,SAAcE,SAAAA,GACZ,IAAMC,SAAN,EAEEA,WAAAA,GAAAA,WACAA,GAFF,YAGEA,GAEAF,EAAAA,KAAqBC,EAAAA,WAArBD,kBAIG9H,EAAP,GAEF,OAAOA,EAAP,I,EAGFiI,2BAAAA,SAA0B,GACpB,gBAAJ,WACE,qCACK,gBADwB,WAA7B,GAKA,6BAGF,mCAAqC,yBAArC,e,EAGKC,WAAAA,SAAU,KACX,cAAJ,GACEC,QAAAA,KAAAA,0BAEA,oB,EAhHN,ICPA,aAGE7K,SAAAA,EAAY8K,GACV,oB,mBAGFjH,MAAAA,SAAAA,GAAK,IAAGpC,EAAH,EAAGA,SACAsJ,EAAmBtJ,EAAAA,MAAAA,IAAAA,UAAAA,KAAzB,IACA,OAAO,kBAAkB,CACvBA,SAAUsJ,IADL,KAEClH,SAAAA,GAAD,YAA6B,EAA7B,CAELM,MAAON,EAAAA,MAAAA,MAAAA,IAAAA,UAAAA,KAF2B,IAGlCmH,UAHkC,EAKlCjJ,EAAGN,EAAAA,OAAAA,EAAsBoC,EALS,EAMlCK,EAAGzC,EAAAA,OAAAA,EAAsBoC,EAAM9B,Q,EAjBrC,GCSA,aAGE/B,SAAAA,EAAY8K,GACV,oB,2BAGFjH,MAAAA,SAAAA,GAKE,IALG,WAAGpC,EAAH,EAAGA,SACAc,EAAN,GACM0I,EAAiB,uBACrB,4BAAoCC,EAAAA,YAHnC,WAKMnJ,GACP,IR3BgBnD,EQ2BVuM,EAAMF,EADqC,GAGjD,GR7BgBrM,EQ6BhB,ER7BiE,IAA5BJ,OAAAA,KAAAA,GAAAA,OQ8BnC,cAEF,IR1BmB,EQ0Bb4M,GR1Ba,EQ0BnB,EAAgC,ERzBlBC,MAAlB,IACOC,KAAeC,SAAAA,GAAD,OAAUC,EAAAA,IAAxBF,KAAAA,KAAP,KQyB8B,eAAkB,CAC1C7J,SAAU2J,IAEZK,SAA2B5H,SAAAA,GACzB,IAAMM,EAAQ1C,EAAAA,MAAeoC,EAAfpC,GAAyBoC,EAAD,KAAtC,KAEA,GAAIM,EAAAA,gBAAwBN,EAA5B,YAA+C,CAE7C,IAAM6H,EAAN,GACAlN,OAAAA,KAAAA,GAAAA,SAA0BmN,SAAAA,GACxB,IAAMC,EAAMT,EAAZ,IACA,IAAIhH,EAAAA,QAAAA,KACFuH,EAAAA,GAAAA,MAGJ,IAAMG,EAAarN,OAAAA,KAAAA,GAAAA,KACX+H,SAAAA,GAAD,OAAUA,EAAV,OAAkBmF,EADNlN,MAAAA,KAAnB,MAGA+D,EAAAA,KAAAA,EAAAA,GAAa,EAAbA,CAEEgG,MAFW,EAGXpE,MAAAA,EACAgH,IAJW,EAKXU,WAAAA,UA9BC9J,EAAT,EAAgBA,EAAIkJ,EAApB,QAAmD,YAA1ClJ,GAAkCA,GAA3C,GAsCA,OAAOQ,EAAAA,QAAgBsB,SAAAA,GAAD,OAAWA,EAAAA,MAAAA,OAAjC,M,EAIFiI,qBAAAA,SAAoB,KAClB,IAAMC,EAAN,GACMC,EAAN,GAYA,OAXAvK,EAAAA,MAAAA,IAAAA,SAA4B8J,SAAAA,GAC1BQ,EAAAA,IAAAA,KAGFvN,OAAAA,KAAAA,GAAAA,SAA4ByN,SAAAA,GAC1B,IACMC,EADOC,EAAb,GACqBC,QAAajB,SAAAA,GAAD,OAAiBA,KAAlD,KACIe,EAAAA,OAAJ,IACEF,EAAAA,GAAAA,MAGJ,G,EAIFK,kBAAAA,SAAiB,GACf,IAAMC,EAAY9N,OAAAA,KAAlB,GAGA,OAFa,eAAwB,CAAxB,IAAb,GAEO,KAAU2M,SAAAA,GACf,IAAMoB,EAAN,GAIA,OAHApB,EAAAA,SAAY,gBAAC,EAAD,YACVoB,EAAAA,GAAAA,KAEF,M,EAIJC,QAAAA,SAAO,OACL,IAAKC,EAAL,OACE,SAEE,IAAEC,EAAWD,EAAjB,GACME,EAAWF,EAAAA,MAAjB,GACMG,EAAN,GACAT,EAAAA,GAAAA,SAA+CU,SAAAA,GAC7CT,EAAAA,SAAcjB,SAAAA,GAEZ,IADA,IAAI2B,GAAJ,EACS/K,EAAT,EAAgBA,EAAIoJ,EAApB,OAAgCpJ,GAAhC,EACE,GAAIoJ,EAAAA,GAAAA,KAAJ,EAA2B,CACzB2B,EAAAA,EACA,MAGJ,QAAIA,EAAqB,CACvB,IAAMC,EAAe5B,EAAAA,OAAW,CAAC,GAAjC,KACAyB,EAAAA,KAAAA,OACK,CACL,IAAMI,EAAiB7B,EAAAA,MAAvB,GACA6B,EAAAA,OAAAA,EAAAA,GACAA,EAAAA,KAAoB,GAApBA,IACAJ,EAAAA,KAAAA,GACAA,EAAAA,KAAAA,UAIN,IAAMK,EAAU,WAAhB,GACA,OAAIN,EAAJ,OACS,iBAAP,GAEF,G,EAGFO,MAAAA,SAAK,GACH,IAAMC,EAAN,GACMC,EAAN,GAUA,OATAhB,EAAAA,SAAcjB,SAAAA,GACZ,IAAMkC,EAAQlC,EAAAA,KAAQ,oBAAc,GAApC,MACAkC,EAAAA,OACA,IAAMC,EAAQD,EAAAA,KAAU,oCAAVA,KAAd,KACMC,KAAN,IACEF,EAAAA,IAAAA,EACAD,EAAAA,KAAAA,OAGJ,G,EApIJ,GCNA,aAKI,SAAFnN,IACE,UAAY,MAAS,KAArB,cACA,aAAe,MAAY,KAA3B,c,2BAGF6D,MAAAA,SAAAA,GAAK,IAAGpC,EAAH,EAAGA,SACAc,EAAO,UACP,kBAAkB,CAAEd,SAAAA,IACpB,mBAAmB,CAAEA,SAAAA,IACrB,gBAAgB,CAAEA,SAAAA,KAExB,OAAOa,EAAP,I,EAGFwI,aAAAA,SAAAA,GAAY,IAAGrJ,EAAH,EAAGA,SAEPc,EAAN,GACMgL,EAAiB9L,EAAvB,OACM+L,EAAgB/L,EAAtB,cAyBA,OAvBAjD,OAAAA,KAAY0M,EAAAA,oBAAZ1M,SAAiDiP,SAAAA,GAGzC,IAFN,IAAMC,EACJxC,EAAAA,mBADF,GAESnJ,EAAT,EAAgBA,EAAhB,EAAoCA,GAApC,EACE,IAAK,IAAImC,EAAT,EAAgBA,EAAhB,EAAoCA,GAApC,EACE,GAAIsJ,EAAAA,MAAAA,GAAuB,KAAvBA,OAAJ,EAAyD,CACvD,IAAM1K,EAAO0K,EAAAA,MAAAA,GAAuB,KAApC,KACMG,EAAOD,EAAb,GACAnL,EAAAA,KAAa,CACXgC,QADW,aAEXxC,EAAAA,EACAmC,EAAAA,EACAC,MAAO1C,EAAAA,MAAAA,GAAkB,KAJd,KAKXmM,YALW9K,EAMX6K,KAAAA,EACAF,eAPW,EAQXzC,UARW,EASXzC,MAAM,QAMhB,G,EAhDJ,GCKA,a,iCACE1E,MAAAA,SAAAA,GAAK,IAAC,EAAD,EAAC,SAAD,IAAagK,QAAAA,OAAb,MAAuBlK,EAAvB,EACGpB,EAAN,GAiBA,OAhBA/D,OAAAA,KAAAA,GAAAA,SAA8B4C,SAAAA,GAC5B,IAAM0M,EAAQD,EAAd,GACAC,EAAAA,UAAAA,EACA,IAAM1J,EAAa0J,EAAAA,KAAnB,GACA,KAAgB,CACd,IAAM3J,EAAQC,EAAd,GACA7B,EAAAA,KAAa,CACXgC,QADW,QAEXJ,MAAAA,EACApC,EAAGqC,EAHQ,MAIXF,EAAGE,EAAAA,MAAmBA,EAAAA,GAAnBA,OAJQ,EAKX2J,UALW,EAMX3J,WAAAA,QAIC9B,EAAP,I,EAnBJ,GCfI0L,EAAW,SAGV,KACD,IAAIC,EAAJ,EACA,GAAI1H,EAAJ,EACE,SAEF,OAAIA,EACF,SAGF,IADA,IAAI2H,EAAJ,EACSnM,EAAT,EAAgBA,GAAhB,EAAwBA,GAAxB,EACEmM,GAAAA,EACAA,GAAAA,EACAD,GAAAA,EAEF,UAjBAD,EAAW,SAmBR,GACH,OAAO/J,KAAAA,IAAAA,GAAcA,KAAAA,IAArB,KCmBEkK,EAAqB,CACzBC,WCjCa,gBAKb,EALgBjK,EAAH,EAAGA,MACZkK,EAAO,SZHyB,GYGIlK,EAAxC,QAaA,OAZIkK,IAAYC,OAAhB,oBACED,EAAUC,OAAVD,WAMAE,EADF,IAAIpK,EAAAA,OACWqK,GAEAC,GAGRxK,KAAAA,IAAAA,EAAP,IDoBAyK,KEtCa,gBAAC,EAAD,EAAC,KAAQlK,EAAT,EAASA,UAIlB6J,EAAJ,IAFkBpK,KAAAA,IAASA,KAAAA,IAASQ,EAAlBR,GbIU,IaG5B,OAHA,IACEoK,GAAAA,GAEF,GF8BAM,WG/Ba,gBAAC,EAAD,EAAC,OAAD,EAAC,WAAD,EAAC,OAAD,EAAC,IAKdxK,EALa,EAKbA,MAEMyK,EAAN,EACMC,ECSQ/L,SAAAA,GAEd,IAAMgM,EAAchM,EAAAA,QAAAA,EAApB,IACA,GACEgM,EAAAA,MAAAA,IACAA,EAAAA,gBAFF,EAIE,SAOF,IAFA,IAAMC,EAAc,KAApB,GACMC,EAAoBD,EAA1B,OACShN,EAAT,EAAgBA,EAAhB,EAAuCA,GAAvC,EAA+C,CAC7C,IAAM+L,EAAQiB,EAAd,GACA,GAAID,EAAAA,MAAJ,GACE,SAOJ,OAzCqBA,SAAAA,GAWnB,IAVF,IAAMG,EAAYH,EAAAA,MAAlB,IACMI,EAAiBD,EAAAA,QAAkB1D,SAAAA,GAAD,OACtCA,EAAAA,MADqB0D,MAAvB,OAGME,EAAiBF,EAAAA,QAAkB1D,SAAAA,GAAD,OACtCA,EAAAA,MADqB0D,MAAvB,OAIIG,EAAJ,EACMC,EAAkBpL,KAAAA,IAAAA,EAAxB,GACSlC,EAAT,EAAgBA,GAAhB,EAAsCA,GAAtC,EACEqN,GAAcpB,EAAUkB,EAAVlB,EAAdoB,GAEF,SA2BOE,CAAP,GDjC4BC,CAA5B,GACMC,EESO,gBAAcrL,EAAd,EAAcA,MAC3B,IADa,EAAC,KAEZ,SAEA,IAAEiL,EAAJ,EACMhD,EALO,EAAC,IAyBZ,OAnBF5N,OAAAA,KAAAA,GAAAA,SAA2BiR,SAAAA,GACzB,MArBc,gBAAC,EAAD,EAAC,OAAgBtL,EAAjB,EAAiBA,MAC3BuL,EADU,EAAC,KACjB,GAEMC,EAAOxL,EAAAA,cAAAA,MAAb,IAKA,MAAO,CACLyL,YAJkBD,EAAAA,QAAapE,SAAAA,GAAD,OAAUA,IAAtBoE,KAApB,OAKEE,cAHoBF,EAAAA,QAAapE,SAAAA,GAAD,OAAUA,IAAtBoE,KAAtB,QAcyCG,CAAU,CAAE1D,KAAAA,EAAMqD,OAAAA,EAAQtL,MAAAA,IAA3D,EAAN,EAAM,YAAe0L,EAArB,EAAqBA,cAErB,GAAID,IAAAA,GAAJ,IAAyBC,EAIvBT,GAAAA,MACK,CAKL,IAFA,IAAM3P,EAAIwE,KAAAA,IAAAA,EAAV,GACI8L,EAAJ,EACShO,EAAT,EAAgBA,GAAhB,EAAwBA,GAAxB,EACEgO,GAAiB/B,EAAU6B,EAAV7B,EAAjB+B,GAEFX,GAAAA,MAGJ,EFlCuBY,CAAY,CAAEzH,KAAAA,EAAM4C,IAAAA,EAAKhH,MAAAA,IAI9C,MAAK,CACLyK,YAAAA,EACAC,oBAAAA,EACAW,eAAAA,EACAS,YALArB,EAAAA,EAAAA,GAF0B5D,EAAD,EAA3B,KHsBA8C,MMxCa,gBAAC,EAAD,EAAC,YAAD,EAAC,WAGd3J,EAHa,EAGbA,MAEM+L,EAAiB,CACrBC,WADqB,GAErBC,WAFqB,GAGrBC,MAHqB,GAIrBC,aAJqB,GAKrBC,OALqB,GAMrBC,QAAS,IAEX,OAAIzC,KAAJ,EACE,SACEmC,EAAAA,GAA4D/L,EAD9D,QAOA,eADF,EAIWF,KAAAA,IACLA,KAAAA,IAASK,SAASF,EAAD,GAARE,IADJL,GjBlBiB,IiBuB5B,GNYAwM,OO1Ca,qBAAC,YAAD,EAAgBC,aP2C7BC,SQ3Ca,gBAAC,EAAD,EAAC,MAASC,EAAV,EAAUA,UACjBC,EAAW1M,EAAAA,OAAjB,GACIyK,EAAJ,EAiBE,OAbAA,EAHqB,yBAAvB,KAEIkC,SAAJ,GACElC,EACSiC,EAAAA,MAAJ,MAA0B,GAK/BjC,GAIF,IACEA,GAAAA,GAEKA,EAAczK,EAArB,QRyBA4M,QSNa,gBAAC,EAAD,EAAC,QAAD,EAAC,QAAD,EAAC,aAMV1C,EA1B2B,YAW/B,IAX+B,IAAC,EAAD,EAAC,QAAD,EAAC,MAGhC2C,EAH+B,EAG/BA,MAEMC,EAAmBzS,OAAAA,KAAY0M,EAAAA,OAAZ1M,IAAzB,OACM0S,EAhBmBC,SAAAA,GACzB,IAAIC,EAAJ,EAMA,OALA5S,OAAAA,KAAAA,GAAAA,SAA4BF,SAAAA,GAC1B,IAAM+S,EAAYF,EAAlB,GACAC,GAAWC,EAAAA,QAAkBC,SAAAA,GAAD,QAAjBD,KAAXD,UAEFA,GAAW5S,OAAAA,QAAAA,GAAX4S,OAUsBG,CAAkBrG,EAAAA,OAAxC,IAEImD,EAAJ,EACMmD,EAAcrN,EAApB,OAESpC,EAAT,EAAgBA,GAAhB,EAAkCA,GAAlC,EAEE,IADA,IAAM0P,EAAgBxN,KAAAA,IAAAA,EAAgBlC,EAAtC,GACSmC,EAAT,EAAgBA,GAAhB,EAAoCA,GAApC,EACEmK,GAAWL,EAAUjM,EAAViM,EAAiB9J,EAAjB8J,GAAAA,EAAAA,KAAAA,IAA6CkD,EAAxD7C,GAGJ,SAScqD,CAAyB,CAAEvN,MAAAA,EAAOgN,MAAAA,EAAOH,MAN1C,EAIbA,QAME,GAAIW,EAAY,CAChB,IAAMC,EAAiBzN,EAAAA,OAAvB,EACA,GAAIwN,IAAAA,GAAJ,IAA0BC,EACxBvD,GAAAA,MACK,CAEL,IADA,IAAIwD,EAAJ,EACS9P,EAAT,EAAgBA,GAAKkC,KAAAA,IAAAA,EAArB,GAA6DlC,GAA7D,EACE8P,GAAqB7D,EAAU2D,EAAV3D,EAArB6D,GAEFxD,GAAAA,GAGJ,OAAOpK,KAAAA,MAAP,KCzDI6N,EAAgB,CACpBrQ,SADoB,GAEpBsQ,QAFoB,GAGpBC,iBAHoB,EAIpBC,UAJoB,SAIX,KAEP,IADA,IAAMrP,EAAN,GACSb,EAAT,EAAgBA,EAAhB,EAA0BA,GAA1B,EAAkC,CAChC,IAAI5C,EAAJ,GACA,WAAI+S,IACF/S,EAAAA,IAEFyD,EAAAA,KAAAA,GAEF,UAGFuP,oBAhBoB,SAgBD,KACjB,MAAO,CACL5N,QADK,aAELJ,MAAO,uBAAuB,KAFzB,KAGLpC,EAAAA,EACAmC,EAAAA,IAMJkO,OA3BoB,SA2Bd,gBACE7L,EAAI1C,EAAV,EACMwO,EV4BK,cACb,IAAMC,EAAN,GAEE,GAAE,eAAJ,MAA0BzO,EAAAA,QACxB,SAGF,IAAM0K,EAjDc,cAIpB,IAAIA,EAAJ,EAQA,OAPI1K,EAAAA,MAAAA,OAAqBpC,EAAzB,SAEI8M,EADF,IAAI1K,EAAAA,MAAAA,OXnBwC,GACD,IWwB7C,EAqCmB0O,CAAa,EAAhC,GAEMC,EAtBW,cACjB,OAAIrE,EAAJ,GACSA,EAAAA,GAAP,GAEEjD,EAAAA,SAAAA,IAA0B,YAAaA,EAAAA,SAA3C,GACSA,EAAAA,SAAAA,GAAAA,QAAP,GAEF,EAeyBuH,CAAW5O,EAAD,QAAnC,GACIwK,EAAJ,EACA,iBAAI,EACFA,EAAAA,EACK,eAAIxK,EAAAA,UACTwK,EAAUmE,EAAVnE,YACAiE,EAAAA,YAAwBE,EAAxBF,YACAA,EAAAA,oBAAgCE,EAAhCF,oBACAA,EAAAA,eAA2BE,EAA3BF,gBAGF,IAAMI,EAAezO,KAAAA,IAAAA,EAArB,GACA,YAAO,IAAP,CAGEoK,QAHK,EAILsE,aAAc3E,EAAAA,KUrDS4E,CAAe,EAAQ,KAA9C,UACIC,EAAKR,EAAT,QACIS,EAAJ,IAKED,GAAM,gBAAgBR,EAAAA,EAAhB,GAAsCS,EAA5CD,IAGF,IAAI7L,EX5CO,SAyBJ,GAEP,IADA,IAAI+L,EAAJ,EACShR,EAAT,EAAgBA,GAAhB,EAA0BA,GAA1B,EAAkCgR,GAAAA,EAClC,SWgBQ/E,CAAAA,GAAR,EACK,KAAL,kBACEhH,GAAC,SrBxC4C,IqBwCA8L,EAA7C9L,IAMF,IAAIgM,GAAJ,EACAxU,OAAAA,KAAY,eAAZA,IAAAA,SAAwCyU,SAAAA,GACtC,IAAMC,EAAuB,eAA7B,GACI5O,SAAQ,EAARA,KAAJ,GACM4O,GAAJ,IACEF,GAAAA,MAIN,IAEE,uBACA,uBACA,0BAKJG,iBAjEoB,SAiEJ,cAEVtP,EAAQ,2BAAZ,GACA,iBACA,IAJc,eAIL9B,GAIP8B,EAAQ,wBAARA,GACA,IAAMuP,EAAM,YAAerR,EALmB,GAO9CvD,OAAAA,KAAAA,GAAAA,SAA0BsU,SAAAA,GAMxB,eALkBM,EAAlB,GAKIC,SAEF,WAAmB/O,SAAQ,EAARA,IAAnB,OAfGvC,EAAT,EAAgBA,GAAhB,EAAwCA,GAAxC,EAAgD,EAAvCA,IAuBXuR,OA5FoB,SA4Fd,GACA,IAAEC,EAAN,GACIhN,EAAIgH,EAAR,EAEIuF,EAAJ,EAEI9L,EAAJ,SACMP,EAAO,eAAb,GAWA,IATA,GACEjI,OAAAA,KAAAA,GAAAA,SAA2BgV,SAAAA,GACzB,IAAMC,EAAuBhN,EAA7B,GACIgN,EAAJ,IACEX,EAAiBxO,SAAQ,EAAzBwO,IACA9L,EAAAA,MAICT,GAAP,GAAe,CACb,IAAM1C,EAAuB,kBAA7B,GACA0P,EAAAA,QAAAA,GACAhN,EAAI1C,EAAAA,EAAJ0C,EACAuM,GAAAA,EAEE,OAAJ,IAIJ,EAAe,CAiCbY,2BAjCa,SAiCa,IAGxB1B,QAHwB,IAGxBA,IAAAA,GAHwB,GAKxBF,EAAAA,SAAAA,EACAA,EAAAA,gBAAAA,EACA,IAAMvE,EAAiB9L,EAAvB,OAEIkS,EAAuB7B,EAAAA,UAAAA,EAA3B,SAKAvP,EAAAA,SAAiBsB,SAAAA,GACf8P,EAAqB9P,EAArB8P,GAAAA,KAAAA,MAGFA,EAAuBA,EAAAA,KAA0B9P,SAAAA,GAAD,OAC9CA,EAAAA,MAAW,qBAA0CrB,EAAAA,EAAOC,EAD9DkR,QAIA7B,EAAAA,QAAwB,CAOtB8B,EAAG9B,EAAAA,UAAAA,EAPmB,UAUtBe,GAAIf,EAAAA,UAAAA,EAVkB,UAYtB9K,EAAG8K,EAAAA,UAAAA,EAAAA,WAGL,IAAK,IAAIvL,EAAT,EAAgBA,EAAhB,EAAoCA,GAApC,EACEoN,EAAAA,GAAAA,SAAiC9P,SAAAA,GAC3BA,EAAAA,EAAJ,EACErF,OAAAA,KAAYsT,EAAAA,QAAAA,EAAwBjO,EAAAA,EAApCrF,IAAAA,SACGsU,SAAAA,GACChB,EAAAA,OAAAA,EAA4BxN,SAAQ,EAARA,IAA5BwN,MAIJA,EAAAA,OAAAA,EAAAA,MAGJA,EAAAA,iBAAAA,GAEF,IAAMyB,EAAuBzB,EAAAA,OAA7B,GACM+B,EAAwBN,EAA9B,OACMlF,EAAU,kBAAhB,GACA,MAAO,CACL5M,SAAAA,EACA4M,QAAAA,EACAsE,aAAc3E,EAHT,GAIL2C,SAAU4C,IAIdO,WA/Fa,SA+FH,KACR,IAAMvG,EAAiB9L,EAAvB,OAQA,OANA,IAAIA,EAAAA,OACF4M,EAGEyD,EAAAA,QAAAA,EAAwBvE,EAAxBuE,GADFzD,KCrNN,c,yCAEExK,MAAAA,SAAAA,GAGE,IAHG,IAAC,EAAD,EAAC,SAAYkQ,EAAb,EAAaA,UACVxR,EAAN,GACIyR,EAAJ,EACOA,EAAYvS,EAAnB,QAAoC,CAClC,IAAMwS,EAAc,sBAApB,GACMC,EAAY,oBAAlB,GACA,SAAID,EACF,MAEF,MAA6B,qBAA7B,GAAM,EAAN,EAAM,MAASE,EAAf,EAAeA,UAEf,KAAW,CACT,IAAMjQ,EAAIL,EAAAA,MAAcA,EAAAA,GAAdA,OAAV,EACM+K,EAAc,sBAApB,GACArM,EAAAA,KAAa,0BAAbA,IAEAyR,EAAY9P,EAAZ8P,GAIJ,IAAMI,EAAc,QAAcvQ,SAAAA,GAChC,OAAOA,aAAP,WAEF,SACSwQ,QAAAA,IAAP,GAEF,G,EAIFC,eAAAA,SAAc,SAMZ,IAAMC,EAAyB,CAC7BhQ,QAD6B,SAE7BxC,EAAG8B,EAF0B,MAG7BK,EAAAA,EACAC,MAAON,EAJsB,GAK7BsQ,UAAAA,EACAvF,YAN6B,EAO7B8B,YAAa7M,EAAAA,GAAAA,OAAkBsQ,EAAUlS,QAE3C,OAAI2M,aAAJ,QACS,QAAkB4F,SAAAA,GACvB,YAAO,EAAP,CAEE5F,YAAa4F,OAInB,KAAO,EAAP,CAEE5F,YAAAA,K,EAIJ6F,eAAAA,SAAc,KACZ,IAAMC,EAAN,WAEA,OADAA,EAAAA,UAAAA,EACOA,EAAAA,KAAP,I,EAGFC,aAAAA,SAAY,KACV,IAAMC,EAAN,YAEA,OADAA,EAAAA,UAAAA,EACOA,EAAAA,KAAP,I,EAGFC,cAAAA,SAAa,KAIX,IACA,EACIV,EAAJ,GACA,GAAID,GAAaD,EAAAA,GAAAA,OAAwBC,EAAAA,GAAzC,OAA8D,CAS5D,IAAMzN,EAZR,aAYeqO,MALbjR,EAJ4D,GAS5D,IACA,IACEsQ,EAAY1N,EAAZ0N,SAMFtQ,EAAAA,KAEEsQ,EAAYtQ,EAAZsQ,IAGJ,MAAO,CACLtQ,MAAAA,EACAsQ,UAAAA,I,EAIJY,eAAAA,SAAc,KACZ,IAAMxS,EAAUwR,EAAAA,MAAhB,GACA,OAAIxR,aAAJ,QACS,QAAcyS,SAAAA,GAKnB,OAJqBC,EAAAA,2BAAAA,EAArB,GAIA,WAGiBA,EAAQvB,2BAARuB,EAArB,GACA,S,EAxHJ,GCMA,cAAE,SAAF,IACE,iB,2BAGApR,MAAAA,SAAAA,GAAK,IAAGpC,EAAH,EAAGA,SAeAmB,EAAN,GACA,OAAInB,EAAAA,OACF,SAKE,IAHJ,IAAIM,EAAJ,EACImT,EAAJ,KACM3H,EAAiB9L,EAAvB,OACS8E,EAAT,EAAgBA,EAAhB,EAAoCA,GAApC,EAA4C,CAC1C,IAAM4O,EAAQ1T,EAAAA,WAAAA,GAAyBA,EAAAA,WAAoB8E,EAA3D,GAIA,GAHA,MAAI2O,IACFA,EAAAA,GAEEC,IAAJ,EAAyB,CACvB,IAAMjR,EAAIqC,EAAV,EACA,YAAY,CACVxE,EAAAA,EACAmC,EAAAA,EACAiR,MAHU,EAIV1T,SAAAA,EACAmB,OAAAA,IAEFb,EAAAA,EACAmT,EAAAA,GAUJ,OAPA,YAAY,CACVnT,EAAAA,EACAmC,EAAGqJ,EAFO,EAGV4H,MAHU,EAIV1T,SAAAA,EACAmB,OAAAA,IAEF,G,EAGFwP,OAAAA,SAAAA,GAAM,IAAC,EAAD,EAAC,IAAD,EAAC,IAAD,EAAC,QAAD,EAAC,SAAyBxP,EAA1B,EAA0BA,OAC9B,GAAIsB,EAAAA,EAAAA,GAAJ,IAAiBD,KAAAA,IAAAA,GAAuB,CACtC,IAAMmR,EAAgBnR,KAAAA,IAAtB,GACA,GAAImR,EAAAA,GAAqBA,GAAiB,KAA1C,UAA0D,CACxD,IAAMjR,EAAQ1C,EAAAA,MAAAA,GAAkB,KAAhC,KACA,EAAwC,iBAAxC,GAAM,EAAN,EAAM,aAAgB4T,EAAtB,EAAsBA,cACtB,OAAO,OAAY,CACjB9Q,QADiB,WAEjBxC,EAAAA,EACAmC,EAAAA,EACAC,MAAO1C,EAAAA,MAAAA,GAAkB,KAJR,KAKjB6T,aAAAA,EACAD,cAAAA,EACAzE,UAAWuE,EAAQ,KAIrB,OAAJ,M,EAGFI,YAAAA,SAAW,GAGL,IAAAD,EAAJ,UACID,EAAJ,GAYA,OAVIjS,EAAAA,KAAJ,IACEkS,EAAAA,QACAD,EAAAA,IACSnS,EAAAA,KAAJ,IACLoS,EAAAA,QACAD,EAAAA,IACS5R,EAAAA,KAAJ,KACL6R,EAAAA,SACAD,EAAAA,IAEK,CACLC,aAAAA,EACAD,cAAAA,I,EA5FN,GCPA,cAAE,SAAF,IACE,oE,2BAEAxR,MAAAA,SAAAA,GAAK,WAAGpC,EAAH,EAAGA,SACAc,EAAN,GAKA,OAJA/D,OAAAA,KAAY0M,EAAAA,QAAZ1M,SAAqCgX,SAAAA,GACnC,IAAMrE,EAAQjG,EAAAA,OAAd,GACA9I,EAAM,EAAU,aAAhBA,OAEKE,EAAP,I,EAGFmT,eAAAA,SAAc,OACZ,OACGD,EAAAA,SAAD,WAEA,qBAAqB/T,EAAAA,OAHvB,IAKE,EAEF,G,EAIFiU,OAAAA,SAAM,OAKJ,IAJA,MACMnT,EAAN,GACIR,EAAJ,EACMwL,EAAiB9L,EAAvB,OACOM,EAAIwL,EAAX,GAA+B,CAC7B,IAAIrJ,EAAInC,EAAR,EACI4T,EAAJ,EACI3E,EAAJ,EAGA,IAFAW,EAAerR,KAAKmV,eAAeD,EAAW/T,EAJjB,KAMhB,CACX,IACMmU,EAAYzE,EADD1P,EAAAA,OAAgByC,EAAjC,KACA,GACI2R,GAAJ,EACIC,GAAJ,EACIC,GALO,EAOX,GAAI7R,EAAJ,EAGE,IAFA,IAAM8R,EAAUvU,EAAAA,OAAhB,GACMwU,EAAkBL,EAAxB,OACSrP,EAAT,EAAgBA,EAAhB,EAAqCA,GAArC,EAA6C,CAC3C,IAAM2P,EAAWN,EAAjB,GAGA,GAFAG,GAF2C,EAI3C,EAAc,CACZ,IAAMI,EAAgBD,EAAAA,QADV,GAGZ,QAAIC,EAAsB,CACxBN,GAAAA,EAGA,IAAIM,IAKFxE,GAAAA,GAGEgE,KAVJG,EAFwB,KAgBtB9E,GAAAA,EACA2E,EAAAA,GAEF,QAMR,MAGO,CAEDzR,EAAAA,EAAJ,GACE3B,EAAAA,KAAa,CACXgC,QADW,UAEXxC,EAAAA,EACAmC,EAAGA,EAHQ,EAIXC,MAAO1C,EAAAA,MAAAA,EAJI,GAKX0P,MALW,EAMXH,MAAAA,EACAW,aAAAA,IAIJ5P,EAAAA,EACA,MAjBAmC,GADS,GAsBX,OAAJ,G,EAnGJ,GCQA,cAAE,SAAF,IACW,cAAqB,CAC5BwK,KAD4B,EAE5BC,WAF4B,EAG5Bb,MAH4B,EAK5B2C,OAL4B,GAM5BE,SAN4B,GAO5BI,QAASqF,I,mBAGXvS,MAAAA,SAAK,cACGtB,EAAN,GAEM8T,EAAN,GA2BA,MA1Bc,UACT7X,OAAAA,KAAY,KADA,UAEZA,OAAAA,KAAY0M,EAAAA,WAEjBiD,SAAkB7P,SAAAA,GAChB,GAAK,WAAD,IAAwB4M,EAAAA,SAA5B,IAGA,IAIMtI,GADc,IAHJ,cACZ,WADY,GAEZsI,EAAAA,SAAAA,GAFJ,WAIe,MAAkB,CAC/BzJ,SAAAA,EACAsS,UAAW,IAGTnR,aAAJ,SACEA,EAAAA,MAAa0T,SAAAA,GACXlU,EAAM,EAANA,MAEFiU,EAAAA,KAAAA,IAEAjU,EAAM,EAANA,OAGAiU,EAAAA,OAAJ,EACS,aAAaE,SAAAA,GAClBlC,QAAAA,IAAAA,GAAAA,MAA2B,WACzBkC,EAAQjU,EAARiU,UAICjU,EAAP,I,EAhDJ,GCTMkU,GAAQ,CACZrN,OATF,EAUEE,OATaoN,GAUblN,KATWmN,KAUX/R,IATUgS,MAUVjS,MATYkS,QAUZnS,KATWoS,SAUXC,QATcC,UAiBhB,c,yCACEC,UAAAA,SAAS,KACP,IAAI1Y,EAAJ,EAKA,YAJIa,IAAAA,GAAJ,IAA2BA,IACzBb,GAAAA,KAEyB4M,EAAAA,aAAAA,eACpBjC,GAAAA,QAAAA,SAAAA,GAAP,I,EAMFgO,oBAAAA,SAAmB,cACXC,EAAuC,CAC3CC,2BAA4B9I,GAAW,IADI,MAE3C+I,8BAA+B/I,EAFY,GAG3CgJ,+BAAgChJ,EAHW,IAI3CiJ,gCAAiCjJ,EAAU,MAEvCkJ,EAAuC,CAC3CJ,2BAD2C,GAE3CC,8BAF2C,GAG3CC,+BAH2C,GAI3CC,gCAAiC,IAOnC,OALA9Y,OAAAA,KAAAA,GAAAA,SAAwCgZ,SAAAA,GACtC,IAAMpO,EAAU8N,EAAhB,GACAK,EAAAA,GACE,cADFA,MAGK,CACLL,kBAAAA,EACAK,kBAAAA,EACAE,MAAO,yB,EAIXC,eAAAA,SAAc,GAEZ,OAAIrJ,EAAU,KAEZ,EAEEA,EAAU,QAEZ,EAEEA,EAAU,UAEZ,EAEEA,EAAU,YAGZ,EAGF,G,EAGFsJ,YAAAA,SAAW,GACT,IACA,EADIC,EAAJ,YAEMC,EAAWrZ,OAAAA,KAAjB,IACMsZ,EAAaD,EAAAA,WAChBE,SAAAA,GAAD,OAAU3O,EAAUoN,GADtB,MAWI,OARAsB,GAAJ,IACEF,EAAaC,EAASC,EAAtBF,GACA,IAAIE,EACFE,EAAO/T,KAAAA,MAAWmF,EAAUoN,GAA5BwB,IAEAJ,EAAAA,YAGG,iBAAP,I,EA5EJ,GC1BI,GAAW,WACb,aCCE,GAAW,WACb,MAAO,CACLK,QAAS/M,EAAAA,aAAAA,SAAAA,MACT5C,YAAa,CAAC4C,EAAAA,aAAAA,YAAAA,SCwDlB,GAAe,cACb,IAAM+M,EAlBqB,cACzB,IAAEA,EAAJ,GACMC,EAAWrU,EAAjB,eACMsU,EACJD,cAAAA,GAA4BA,EAAAA,cAAAA,SAD9B,cAWA,MATA,cAAIA,EACFD,EA9CiC,cAIjC,IAAEA,EAAJ,GAYA,OAXIG,GAAgBvU,EAAhBuU,MAA+BvU,EAAnC,SAQWA,EAAAA,cAAJ,IACLoU,EAAU/M,EAAAA,aAAAA,SAAAA,iBAPR+M,EADEpU,EAAAA,MAAJ,GACYqH,EAAAA,aAAAA,SAAAA,OACDrH,EAAAA,MAAJ,IACKqH,EAAAA,aAAAA,SAAAA,WAEAA,EAAAA,aAAAA,SAAAA,OAKd,EA8BYmN,CAA4B,EAAtCJ,GACSC,EAAAA,SAAJ,aACLD,EA7BkC,cAIpC,IAAIA,EAAJ,GAIA,OAHA,IACEA,EAAU/M,EAAAA,aAAAA,SAAAA,cAEZ,EAqBYoN,CAA6B,EAAvCL,GACK,EACLA,EApB8B,cAIhC,SACS/M,EAAAA,aAAAA,SAAAA,kBAEFA,EAAAA,aAAAA,SAAAA,YAaKqN,CAAyB,EAAnCN,GACK,eAAIC,IACTD,EAAU/M,EAAAA,aAAAA,SAAAA,YAEZ,EAIgBsN,CAAoB,EAApC,GACMlQ,EAAN,GACMxF,EAAOe,EAAb,MAaE,OAXEf,EAAAA,MAAJ,GACEwF,EAAAA,KAAiB4C,EAAAA,aAAAA,YAAAA,gBACRpI,EAAAA,MAAAA,IAAkCA,EAAAA,gBAAtC,GACLwF,EAAAA,KAAiB4C,EAAAA,aAAAA,YAAAA,cAEfrH,EAAAA,UAAkBA,EAAAA,MAAAA,QAAtB,GACEyE,EAAAA,KAAiB4C,EAAAA,aAAAA,YAAAA,cAEfrH,EAAJ,MACEyE,EAAAA,KAAiB4C,EAAAA,aAAAA,YAAAA,MAEZ,CACL+M,QAAAA,EACA3P,YAAAA,IC5EJ,GAAgBzE,SAAAA,GACZ,MAAF,eAAIA,EAAAA,UACK,CACLoU,QAAS/M,EAAAA,aAAAA,SAAAA,YACT5C,YAAa,CACX4C,EAAAA,aAAAA,YAAAA,YACAA,EAAAA,aAAAA,YAAAA,kBAIC,CACL+M,QADK,GAEL3P,YAAa,KCZjB,GAAgBzE,SAAAA,GACd,IAAIoU,EAAU/M,EAAAA,aAAAA,SAAAA,eAKd,OAJA,IAAIrH,EAAAA,UAAAA,SACFoU,EAAU/M,EAAAA,aAAAA,SAAAA,cAGL,CACL+M,QAAAA,EACA3P,YAAa,CAAC4C,EAAAA,aAAAA,YAAAA,YCTd,GAAW,WACb,MAAO,CACL+M,QAAS/M,EAAAA,aAAAA,SAAAA,UACT5C,YAAa,CAAC4C,EAAAA,aAAAA,YAAAA,aCFlB,GAAgBrH,SAAAA,GACd,IAAIoU,EAAU/M,EAAAA,aAAAA,SAAAA,WAId,OAHA,IAAIrH,EAAAA,QACFoU,EAAU/M,EAAAA,aAAAA,SAAAA,aAEL,CACL+M,QAAAA,EACA3P,YAAa,CAAC4C,EAAAA,aAAAA,YAAAA,yBCAZuN,GAAkB,CACtBR,QADsB,GAEtB3P,YAAa,IAWf,cAgBEtI,SAAAA,IAfS,cAAqB,CAC5BoO,WAD4B,GAE5BM,KAF4B,GAG5BC,WAH4B,GAI5Bb,MAJ4B,GAK5B2C,OAL4B,GAM5BE,SAN4B,GAO5BI,QAASqF,IAGX,qBAAgC,CAC9B6B,QAD8B,GAE9B3P,YAAa,IAIb,6B,2BAGFoQ,sBAAAA,WACE,sCACExN,EAAAA,aAAAA,YAAAA,SACAA,EAAAA,aAAAA,YAAAA,S,EAIJyN,YAAAA,SAAW,KACT,OAAIhI,EAAAA,OACF,OAAO,KAAP,gBAEF,GAAI8G,EAAJ,EACE,UAEF,IAAMmB,EAAgB1N,EAAAA,aAAAA,YAAAA,YAChB2N,EAAe,qBAArB,GACIC,EAAW,wBAAf,IAAmDnI,EAAAA,QAYnD,OAXImI,MAAAA,GACFA,EAAAA,YAAAA,QAAAA,GACA,MAAIA,EAAAA,UACFA,EAAAA,QAAAA,KAGFA,EAAW,CACTb,QADS,GAET3P,YAAa,KAGjB,G,EAGFyQ,gBAAAA,SAAe,GACT,IAAAF,EAAelI,EAAnB,GAOA,OANuBA,EAAAA,MAAvB,GACAqI,SAAwBnV,SAAAA,GAClBA,EAAAA,MAAAA,OAAqBgV,EAAAA,MAAzB,SACEA,EAAAA,MAGJ,G,EAGFI,iBAAAA,SAAgB,KACd,OAAI,cAAcpV,EAAlB,SACS,cAAcA,EAAd,WAAP,GAGAqH,EAAAA,SAAiBrH,EAAjBqH,UACA,aAAcA,EAAAA,SAAiBrH,EAFjC,SAISqH,EAAAA,SAAiBrH,EAAjBqH,SAAAA,SAAAA,EAAP,GAEF,I,EAxEJ,GChBM6M,GAAO,kBAAM,IAAImB,MAAvB,WAEMC,GAAoB,SAACnE,EAAiBvT,EAAU2X,GAKpD,IAAMN,EAAW,IAAjB,GACMO,EAAgB,IAAtB,GACMC,EAAgBrE,EAAAA,2BAAAA,EAAtB,GAIMsE,EAAWxB,KAAjB,EACMyB,EAAcH,EAAAA,oBAAkCC,EAAtD,SAEA,UACEC,SAAAA,GADK,IAAP,CAIET,SAAUA,EAAAA,YACRU,EADQV,MAERQ,EAFQR,aChBOW,GAAAA,SAAAA,G,oFACpBvZ,OAAA,SAAOC,GACN,YAAMD,OAAN,UAAaC,I,EAGdC,KAAA,WAAO,WACN,EAAyBE,KAAKC,MAAtB+M,EAAR,EAAQA,MAAOoM,EAAf,EAAeA,MACf,OACC,SAAKlZ,UAAS,sBAAuB8M,EAAQ,SAAW,KACvD,SAAK9M,UAAU,+BACd,SAAKA,UAAU,2BACb,CAAC,OAAQ,SAAU,UAAUmZ,KAAI,SAACrb,GAAD,OACjC,EAACsb,GAAD,CAAcF,MAAOA,EAAOG,OAAQ,EAAKC,aAAaxb,SAGxD,SAAKkC,UAAU,2BACd,cAAO8M,O,EAOZwM,aAAA,SAAaxb,GACZ,IAAQmZ,EAAUnX,KAAKC,MAAfkX,MACR,OAAQnZ,GACP,IAAK,OACJ,GAAIgQ,OAAOyL,UAAUtC,GACpB,OAAO,EAET,IAAK,SACJ,GAAIA,GAAS,EACZ,OAAO,EAET,IAAK,SACJ,GAAIA,GAAS,EACZ,OAAO,EAGT,QACC,OAAO,I,EAxCUgC,CAA0B9Y,KA6CzCiZ,GAAAA,SAAAA,G,4EACLxZ,KAAA,WACC,MAA0BE,KAAKC,MAAvBmZ,EAAR,EAAQA,MAAOG,EAAf,EAAeA,OAEf,OAAO,SAAKrZ,UAAU,eAAewZ,MAAO,CAAEC,gBADtBJ,EAASH,OAAQQ,M,EAHrCN,CAAqBjZ,KCtCrBC,GAAIC,IAAIC,WAAWC,MAAMC,KAAKH,IAAIC,YAClCqZ,GAAU5a,EAAN,wBAEJ6a,GAAW,SAAC9b,GAAD,OAASuC,IAAIwZ,MAAMC,UAAa/a,EAAvB,IAA+BjB,IAEpCic,GAAAA,SAAAA,G,oFACpBra,OAAA,SAAOC,GACN,YAAMD,OAAN,UAAaC,GAEbG,KAAKka,cAAgB,IAAIC,IAAJ,CAAW,IAChCna,KAAKoa,cAAgB,IAAID,IAAJ,MAAWP,GAChC5Z,KAAKqa,cAAgB,IAAIF,IAAJ,CAAW,K,EAGjCra,KAAA,WACC,MAA0EE,KAAKC,MAAvEW,EAAR,EAAQA,YAAaC,EAArB,EAAqBA,gBAAiByZ,EAAtC,EAAsCA,gBAAiBC,EAAvD,EAAuDA,eAEvD,OAKC,SAAKra,UAAU,4BACd,WACCA,UAAS,gBAAiB4Z,GAAS,wBAA0B,YAAc,IAC3EhZ,KAAMyZ,EAAiB,kBAAoB,WAC3CxZ,KAAMF,IAAoB,OAAS,WACnCG,YACCuZ,EACGja,GAAE,2DACFW,GAAAA,CAAYX,GAAE,4CAElBzB,MAAO0b,EAAiB3Z,EAAY4Z,kBAAoB5Z,EAAYO,WACpEC,SAAUR,EAAYS,QACtBoZ,QAASza,KAAK0a,aAAaha,KAAKV,MAChC0Z,MAAO,CACNN,OACCU,GAAS,qBACRjZ,KACCyZ,IAAmBC,OAElBX,EADA5Z,KAAKqa,gBAETM,aACCb,GAAS,2BACPQ,IAAmBC,OAElBX,EADA5Z,KAAKqa,mBAKVP,GAAS,wBAA0B,EAACna,EAAD,CAAWI,QAASc,IAAsB,MAE5EyZ,GAAmBC,EACpB,EAACpB,GAAD,CACChC,MAAOnX,KAAKoa,gBACZpN,MAAOhN,KAAKka,gBACZd,MAAOpZ,KAAKqa,kBAEV,O,EAKPK,aAAA,SAAajU,GACZ,MAAwCzG,KAAKC,MAArCW,EAAR,EAAQA,YAAa2Z,EAArB,EAAqBA,eAEfpZ,EAAWsF,EAAEjF,OAAO3C,MAQ1B,GANI0b,EACH3Z,EAAY4Z,gBAAgBrZ,GAE5BP,EAAYO,SAASA,GAGlBA,EAAU,CAEb,MF5DmB,cAKpB,IAAMyZ,EAAW,IAAjB,GAEM9B,EAAQrB,KAERxV,EAAU2Y,EAAAA,MAAhB,GAEA,OAAI3Y,aAAJ,QACS,QAAcyS,SAAAA,GACnB,OAAOmE,GAAiB,IAAxB,MAGGA,GAAiB,IAAxB,GE4CiBgC,CAAO1Z,GAAjBgW,EAAN,EAAMA,MAIN,OAHAnX,KAAKoa,cAAcjD,GAGXA,GACP,KAAK,EACL,KAAK,EACJnX,KAAKka,cAAc5Z,GAAKuZ,GAAJ,UACpB7Z,KAAKqa,cAAL,OAA0BP,GAAS,aAAnC,KACA,MAED,KAAK,EACL,KAAK,EACJ9Z,KAAKka,cAAc5Z,GAAKuZ,GAAJ,YACpB7Z,KAAKqa,cAAL,OAA0BP,GAAS,eAAnC,KACA,MAED,KAAK,EACJ9Z,KAAKka,cAAc5Z,GAAKuZ,GAAJ,YACpB7Z,KAAKqa,cAAL,OAA0BP,GAAS,eAAnC,WAIF9Z,KAAKoa,mBAAcR,GACnB5Z,KAAKka,cAAc,IACnBla,KAAKqa,mBAAcT,I,EAhGDK,CAA4B5Z,KCLjDE,IAAAA,aAAAA,IAAqBtB,GAAM,WAC1B,SAAS6b,IACR9a,KAAKa,gBAAkB,IAAIsZ,IAAJ,EAAW,IAEnCrY,EAAAA,EAAAA,QAAOiZ,IAAAA,UAAsB,SAAUD,IACvChZ,EAAAA,EAAAA,QAAOkZ,IAAAA,UAAuB,SAAUF,IAExChZ,EAAAA,EAAAA,QAAOiZ,IAAAA,UAAsB,UAAU,SAAUE,GAC5C1a,IAAAA,MAAAA,UAAuBtB,EAAvB,0BACHgc,EAAMC,WACL,WACA,EAACva,EAAD,CACCC,YAAaZ,KACba,gBAAiBb,KAAKa,gBAAgBH,KAAKV,aAM/C8B,EAAAA,EAAAA,QAAOkZ,IAAAA,UAAuB,UAAU,SAAUC,GACjD,IAAKjb,KAAKC,MAAM4D,MAAO,CACtB,IAAMyW,EACLW,EAAME,IAAI,gCAAsDvB,IAAzB5Z,KAAKwa,gBAE7CS,EAAMC,WACL,WACA,EAACjB,GAAD,CACCrZ,YAAaZ,KACba,gBAAiBb,KAAKa,gBAAgBH,KAAKV,MAC3Csa,gBAAiBA,KAIfA,GACHW,EAAMC,WACL,yBACA,EAACjB,GAAD,CACCrZ,YAAaZ,KACba,gBAAiBb,KAAKa,gBAAgBH,KAAKV,MAC3Csa,gBAAiBA,EACjBC,gBAAgB,a","sources":["webpack://@glowingblue/password-strength/webpack/bootstrap","webpack://@glowingblue/password-strength/webpack/runtime/compat get default export","webpack://@glowingblue/password-strength/webpack/runtime/define property getters","webpack://@glowingblue/password-strength/webpack/runtime/hasOwnProperty shorthand","webpack://@glowingblue/password-strength/webpack/runtime/make namespace object","webpack://@glowingblue/password-strength/external root \"flarum.core.compat['common/app']\"","webpack://@glowingblue/password-strength/external root \"flarum.core.compat['common/extend']\"","webpack://@glowingblue/password-strength/external root \"flarum.core.compat['forum/components/LogInModal']\"","webpack://@glowingblue/password-strength/external root \"flarum.core.compat['forum/components/SignUpModal']\"","webpack://@glowingblue/password-strength/external root \"flarum.core.compat['common/utils/Stream']\"","webpack://@glowingblue/password-strength/./src/common/index.js","webpack://@glowingblue/password-strength/./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack://@glowingblue/password-strength/./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","webpack://@glowingblue/password-strength/external root \"flarum.core.compat['common/Component']\"","webpack://@glowingblue/password-strength/external root \"flarum.core.compat['common/utils/extractText']\"","webpack://@glowingblue/password-strength/external root \"flarum.core.compat['common/helpers/icon']\"","webpack://@glowingblue/password-strength/./src/forum/components/EyeButton.js","webpack://@glowingblue/password-strength/./src/forum/components/LogInPasswordField.js","webpack://@glowingblue/password-strength/./node_modules/@babel/runtime/helpers/esm/extends.js","webpack://@glowingblue/password-strength/../src/helper.ts","webpack://@glowingblue/password-strength/../../src/data/const.ts","webpack://@glowingblue/password-strength/../../src/data/dateSplits.ts","webpack://@glowingblue/password-strength/../../../src/matcher/date/matching.ts","webpack://@glowingblue/password-strength/../../src/data/l33tTable.ts","webpack://@glowingblue/password-strength/../../src/data/translationKeys.ts","webpack://@glowingblue/password-strength/../src/Options.ts","webpack://@glowingblue/password-strength/../../../src/matcher/dictionary/variants/matching/reverse.ts","webpack://@glowingblue/password-strength/../../../src/matcher/dictionary/variants/matching/l33t.ts","webpack://@glowingblue/password-strength/../../../src/matcher/dictionary/matching.ts","webpack://@glowingblue/password-strength/../../../src/matcher/regex/matching.ts","webpack://@glowingblue/password-strength/../../src/scoring/utils.ts","webpack://@glowingblue/password-strength/../../src/scoring/estimate.ts","webpack://@glowingblue/password-strength/../../../src/matcher/bruteforce/scoring.ts","webpack://@glowingblue/password-strength/../../../src/matcher/date/scoring.ts","webpack://@glowingblue/password-strength/../../../src/matcher/dictionary/scoring.ts","webpack://@glowingblue/password-strength/../../../src/matcher/dictionary/variants/scoring/uppercase.ts","webpack://@glowingblue/password-strength/../../../src/matcher/dictionary/variants/scoring/l33t.ts","webpack://@glowingblue/password-strength/../../../src/matcher/regex/scoring.ts","webpack://@glowingblue/password-strength/../../../src/matcher/repeat/scoring.ts","webpack://@glowingblue/password-strength/../../../src/matcher/sequence/scoring.ts","webpack://@glowingblue/password-strength/../../../src/matcher/spatial/scoring.ts","webpack://@glowingblue/password-strength/../../src/scoring/index.ts","webpack://@glowingblue/password-strength/../../../src/matcher/repeat/matching.ts","webpack://@glowingblue/password-strength/../../../src/matcher/sequence/matching.ts","webpack://@glowingblue/password-strength/../../../src/matcher/spatial/matching.ts","webpack://@glowingblue/password-strength/../src/Matching.ts","webpack://@glowingblue/password-strength/../src/TimeEstimates.ts","webpack://@glowingblue/password-strength/../../../src/matcher/bruteforce/feedback.ts","webpack://@glowingblue/password-strength/../../../src/matcher/date/feedback.ts","webpack://@glowingblue/password-strength/../../../src/matcher/dictionary/feedback.ts","webpack://@glowingblue/password-strength/../../../src/matcher/regex/feedback.ts","webpack://@glowingblue/password-strength/../../../src/matcher/repeat/feedback.ts","webpack://@glowingblue/password-strength/../../../src/matcher/sequence/feedback.ts","webpack://@glowingblue/password-strength/../../../src/matcher/spatial/feedback.ts","webpack://@glowingblue/password-strength/../src/Feedback.ts","webpack://@glowingblue/password-strength/../src/index.ts","webpack://@glowingblue/password-strength/./src/forum/components/StrengthIndicator.js","webpack://@glowingblue/password-strength/./src/forum/components/SignUpPasswordField.js","webpack://@glowingblue/password-strength/./src/forum/index.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['common/app'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['common/extend'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/LogInModal'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['forum/components/SignUpModal'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['common/utils/Stream'];","/*\n * This file is part of glowingblue/password-strength.\n *\n * Copyright (c) 2021 Rafael Horvat.\n *\n * For the full copyright and license information, please view the LICENSE.md\n * file that was distributed with this source code.\n */\n\nexport const slug = 'glowingblue-password-strength';\n","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['common/Component'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['common/utils/extractText'];","const __WEBPACK_NAMESPACE_OBJECT__ = flarum.core.compat['common/helpers/icon'];","/*\n * This file is part of glowingblue/password-strength.\n *\n * Copyright (c) 2021 Rafael Horvat.\n *\n * For the full copyright and license information, please view the LICENSE.md\n * file that was distributed with this source code.\n */\n\nimport Component from 'flarum/common/Component';\nimport icon from 'flarum/common/helpers/icon';\n\nexport default class EyeButton extends Component {\n\toninit(vnode) {\n\t\tsuper.oninit(vnode);\n\t}\n\n\tview() {\n\t\tconst { showing } = this.attrs;\n\t\treturn (\n\t\t\t<span className='EyeButton' onclick={() => showing(!showing())}>\n\t\t\t\t{icon(`fas fa-eye${showing() ? '-slash' : ''}`)}\n\t\t\t</span>\n\t\t);\n\t}\n}\n","/*\n * This file is part of glowingblue/password-strength.\n *\n * Copyright (c) 2021 Rafael Horvat.\n *\n * For the full copyright and license information, please view the LICENSE.md\n * file that was distributed with this source code.\n */\n\nimport Component from 'flarum/common/Component';\nimport extractText from 'flarum/common/utils/extractText';\nimport EyeButton from './EyeButton';\n\n// Make translation calls shorter\nconst t = app.translator.trans.bind(app.translator);\n\nexport default class LogInPasswordField extends Component {\n\toninit(vnode) {\n\t\tsuper.oninit(vnode);\n\t}\n\n\tview() {\n\t\tconst { parent_this, showingPassword } = this.attrs;\n\n\t\treturn (\n\t\t\t// This markup is copied from `flarum/components/LogInModal` and then\n\t\t\t// some things have been added.\n\t\t\t// !!! Please check for updates regularly !!!\n\n\t\t\t<div className='Form-group PasswordField'>\n\t\t\t\t<input\n\t\t\t\t\tclassName='FormControl togglable'\n\t\t\t\t\tname='password'\n\t\t\t\t\ttype={showingPassword() ? 'text' : 'password'}\n\t\t\t\t\tplaceholder={extractText(t('core.forum.log_in.password_placeholder'))}\n\t\t\t\t\tbidi={parent_this.password}\n\t\t\t\t\tdisabled={parent_this.loading}\n\t\t\t\t/>\n\t\t\t\t<EyeButton showing={showingPassword} />\n\t\t\t</div>\n\t\t);\n\t}\n}\n","export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","const empty = obj => Object.keys(obj).length === 0;\nconst extend = (listToExtend, list) => // eslint-disable-next-line prefer-spread\nlistToExtend.push.apply(listToExtend, list);\nconst translate = (string, chrMap) => {\n  const tempArray = string.split('');\n  return tempArray.map(char => chrMap[char] || char).join('');\n}; // mod implementation that works for negative numbers\n\nconst sorted = matches => matches.sort((m1, m2) => m1.i - m2.i || m1.j - m2.j);\nconst buildRankedDictionary = orderedList => {\n  const result = {};\n  let counter = 1; // rank starts at 1, not 0\n\n  orderedList.forEach(word => {\n    result[word] = counter;\n    counter += 1;\n  });\n  return result;\n};\n\nexport { buildRankedDictionary, empty, extend, sorted, translate };\n//# sourceMappingURL=helper.esm.js.map\n","import dateSplits from './dateSplits.esm.js';\n\nconst DATE_MAX_YEAR = 2050;\nconst DATE_MIN_YEAR = 1000;\nconst DATE_SPLITS = dateSplits;\nconst BRUTEFORCE_CARDINALITY = 10;\nconst MIN_GUESSES_BEFORE_GROWING_SEQUENCE = 10000;\nconst MIN_SUBMATCH_GUESSES_SINGLE_CHAR = 10;\nconst MIN_SUBMATCH_GUESSES_MULTI_CHAR = 50;\nconst MIN_YEAR_SPACE = 20; // \\xbf-\\xdf is a range for almost all special uppercase letter like Ä and so on\n\nconst START_UPPER = /^[A-Z\\xbf-\\xdf][^A-Z\\xbf-\\xdf]+$/;\nconst END_UPPER = /^[^A-Z\\xbf-\\xdf]+[A-Z\\xbf-\\xdf]$/; // \\xdf-\\xff is a range for almost all special lowercase letter like ä and so on\n\nconst ALL_UPPER = /^[A-Z\\xbf-\\xdf]+$/;\nconst ALL_UPPER_INVERTED = /^[^a-z\\xdf-\\xff]+$/;\nconst ALL_LOWER = /^[a-z\\xdf-\\xff]+$/;\nconst ALL_LOWER_INVERTED = /^[^A-Z\\xbf-\\xdf]+$/;\nconst ONE_UPPER = /[a-z\\xdf-\\xff]/;\nconst ONE_LOWER = /[A-Z\\xbf-\\xdf]/;\nconst ALPHA_INVERTED = /[^A-Za-z\\xbf-\\xdf]/gi;\nconst ALL_DIGIT = /^\\d+$/;\nconst REFERENCE_YEAR = new Date().getFullYear();\nconst REGEXEN = {\n  recentYear: /19\\d\\d|200\\d|201\\d|202\\d/g\n};\n\nexport { ALL_DIGIT, ALL_LOWER, ALL_LOWER_INVERTED, ALL_UPPER, ALL_UPPER_INVERTED, ALPHA_INVERTED, BRUTEFORCE_CARDINALITY, DATE_MAX_YEAR, DATE_MIN_YEAR, DATE_SPLITS, END_UPPER, MIN_GUESSES_BEFORE_GROWING_SEQUENCE, MIN_SUBMATCH_GUESSES_MULTI_CHAR, MIN_SUBMATCH_GUESSES_SINGLE_CHAR, MIN_YEAR_SPACE, ONE_LOWER, ONE_UPPER, REFERENCE_YEAR, REGEXEN, START_UPPER };\n//# sourceMappingURL=const.esm.js.map\n","var dateSplits = {\n  4: [[1, 2], [2, 3]],\n  5: [[1, 3], [2, 3]],\n  6: [[1, 2], [2, 4], [4, 5]],\n  7: [[1, 3], [2, 3], [4, 5], [4, 6]],\n  8: [[2, 4], [4, 6]]\n};\n\nexport { dateSplits as default };\n//# sourceMappingURL=dateSplits.esm.js.map\n","import { REFERENCE_YEAR, DATE_MIN_YEAR, DATE_MAX_YEAR, DATE_SPLITS } from '../../data/const.esm.js';\nimport { sorted } from '../../helper.esm.js';\n\n/*\n * -------------------------------------------------------------------------------\n *  date matching ----------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\n\nclass MatchDate {\n  /*\n   * a \"date\" is recognized as:\n   *   any 3-tuple that starts or ends with a 2- or 4-digit year,\n   *   with 2 or 0 separator chars (1.1.91 or 1191),\n   *   maybe zero-padded (01-01-91 vs 1-1-91),\n   *   a month between 1 and 12,\n   *   a day between 1 and 31.\n   *\n   * note: this isn't true date parsing in that \"feb 31st\" is allowed,\n   * this doesn't check for leap years, etc.\n   *\n   * recipe:\n   * start with regex to find maybe-dates, then attempt to map the integers\n   * onto month-day-year to filter the maybe-dates into dates.\n   * finally, remove matches that are substrings of other matches to reduce noise.\n   *\n   * note: instead of using a lazy or greedy regex to find many dates over the full string,\n   * this uses a ^...$ regex against every substring of the password -- less performant but leads\n   * to every possible date match.\n   */\n  match({\n    password\n  }) {\n    const matches = [...this.getMatchesWithoutSeparator(password), ...this.getMatchesWithSeparator(password)];\n    const filteredMatches = this.filterNoise(matches);\n    return sorted(filteredMatches);\n  }\n\n  getMatchesWithSeparator(password) {\n    const matches = [];\n    const maybeDateWithSeparator = /^(\\d{1,4})([\\s/\\\\_.-])(\\d{1,2})\\2(\\d{1,4})$/; // # dates with separators are between length 6 '1/1/91' and 10 '11/11/1991'\n\n    for (let i = 0; i <= Math.abs(password.length - 6); i += 1) {\n      for (let j = i + 5; j <= i + 9; j += 1) {\n        if (j >= password.length) {\n          break;\n        }\n\n        const token = password.slice(i, +j + 1 || 9e9);\n        const regexMatch = maybeDateWithSeparator.exec(token);\n\n        if (regexMatch != null) {\n          const dmy = this.mapIntegersToDayMonthYear([parseInt(regexMatch[1], 10), parseInt(regexMatch[3], 10), parseInt(regexMatch[4], 10)]);\n\n          if (dmy != null) {\n            matches.push({\n              pattern: 'date',\n              token,\n              i,\n              j,\n              separator: regexMatch[2],\n              year: dmy.year,\n              month: dmy.month,\n              day: dmy.day\n            });\n          }\n        }\n      }\n    }\n\n    return matches;\n  } // eslint-disable-next-line max-statements\n\n\n  getMatchesWithoutSeparator(password) {\n    const matches = [];\n    const maybeDateNoSeparator = /^\\d{4,8}$/;\n\n    const metric = candidate => Math.abs(candidate.year - REFERENCE_YEAR); // # dates without separators are between length 4 '1191' and 8 '11111991'\n\n\n    for (let i = 0; i <= Math.abs(password.length - 4); i += 1) {\n      for (let j = i + 3; j <= i + 7; j += 1) {\n        if (j >= password.length) {\n          break;\n        }\n\n        const token = password.slice(i, +j + 1 || 9e9);\n\n        if (maybeDateNoSeparator.exec(token)) {\n          const candidates = [];\n          const index = token.length;\n          const splittedDates = DATE_SPLITS[index];\n          splittedDates.forEach(([k, l]) => {\n            const dmy = this.mapIntegersToDayMonthYear([parseInt(token.slice(0, k), 10), parseInt(token.slice(k, l), 10), parseInt(token.slice(l), 10)]);\n\n            if (dmy != null) {\n              candidates.push(dmy);\n            }\n          });\n\n          if (candidates.length > 0) {\n            /*\n             * at this point: different possible dmy mappings for the same i,j substring.\n             * match the candidate date that likely takes the fewest guesses: a year closest\n             * to 2000.\n             * (scoring.REFERENCE_YEAR).\n             *\n             * ie, considering '111504', prefer 11-15-04 to 1-1-1504\n             * (interpreting '04' as 2004)\n             */\n            let bestCandidate = candidates[0];\n            let minDistance = metric(candidates[0]);\n            candidates.slice(1).forEach(candidate => {\n              const distance = metric(candidate);\n\n              if (distance < minDistance) {\n                bestCandidate = candidate;\n                minDistance = distance;\n              }\n            });\n            matches.push({\n              pattern: 'date',\n              token,\n              i,\n              j,\n              separator: '',\n              year: bestCandidate.year,\n              month: bestCandidate.month,\n              day: bestCandidate.day\n            });\n          }\n        }\n      }\n    }\n\n    return matches;\n  }\n  /*\n   * matches now contains all valid date strings in a way that is tricky to capture\n   * with regexes only. while thorough, it will contain some unintuitive noise:\n   *\n   * '2015_06_04', in addition to matching 2015_06_04, will also contain\n   * 5(!) other date matches: 15_06_04, 5_06_04, ..., even 2015 (matched as 5/1/2020)\n   *\n   * to reduce noise, remove date matches that are strict substrings of others\n   */\n\n\n  filterNoise(matches) {\n    return matches.filter(match => {\n      let isSubmatch = false;\n      const matchesLength = matches.length;\n\n      for (let o = 0; o < matchesLength; o += 1) {\n        const otherMatch = matches[o];\n\n        if (match !== otherMatch) {\n          if (otherMatch.i <= match.i && otherMatch.j >= match.j) {\n            isSubmatch = true;\n            break;\n          }\n        }\n      }\n\n      return !isSubmatch;\n    });\n  }\n  /*\n   * given a 3-tuple, discard if:\n   *   middle int is over 31 (for all dmy formats, years are never allowed in the middle)\n   *   middle int is zero\n   *   any int is over the max allowable year\n   *   any int is over two digits but under the min allowable year\n   *   2 integers are over 31, the max allowable day\n   *   2 integers are zero\n   *   all integers are over 12, the max allowable month\n   */\n  // eslint-disable-next-line complexity, max-statements\n\n\n  mapIntegersToDayMonthYear(integers) {\n    if (integers[1] > 31 || integers[1] <= 0) {\n      return null;\n    }\n\n    let over12 = 0;\n    let over31 = 0;\n    let under1 = 0;\n\n    for (let o = 0, len1 = integers.length; o < len1; o += 1) {\n      const int = integers[o];\n\n      if (int > 99 && int < DATE_MIN_YEAR || int > DATE_MAX_YEAR) {\n        return null;\n      }\n\n      if (int > 31) {\n        over31 += 1;\n      }\n\n      if (int > 12) {\n        over12 += 1;\n      }\n\n      if (int <= 0) {\n        under1 += 1;\n      }\n    }\n\n    if (over31 >= 2 || over12 === 3 || under1 >= 2) {\n      return null;\n    }\n\n    return this.getDayMonth(integers);\n  } // eslint-disable-next-line max-statements\n\n\n  getDayMonth(integers) {\n    // first look for a four digit year: yyyy + daymonth or daymonth + yyyy\n    const possibleYearSplits = [[integers[2], integers.slice(0, 2)], [integers[0], integers.slice(1, 3)] // year first\n    ];\n    const possibleYearSplitsLength = possibleYearSplits.length;\n\n    for (let j = 0; j < possibleYearSplitsLength; j += 1) {\n      const [y, rest] = possibleYearSplits[j];\n\n      if (DATE_MIN_YEAR <= y && y <= DATE_MAX_YEAR) {\n        const dm = this.mapIntegersToDayMonth(rest);\n\n        if (dm != null) {\n          return {\n            year: y,\n            month: dm.month,\n            day: dm.day\n          };\n        }\n        /*\n         * for a candidate that includes a four-digit year,\n         * when the remaining integers don't match to a day and month,\n         * it is not a date.\n         */\n\n\n        return null;\n      }\n    } // given no four-digit year, two digit years are the most flexible int to match, so\n    // try to parse a day-month out of integers[0..1] or integers[1..0]\n\n\n    for (let k = 0; k < possibleYearSplitsLength; k += 1) {\n      const [y, rest] = possibleYearSplits[k];\n      const dm = this.mapIntegersToDayMonth(rest);\n\n      if (dm != null) {\n        return {\n          year: this.twoToFourDigitYear(y),\n          month: dm.month,\n          day: dm.day\n        };\n      }\n    }\n\n    return null;\n  }\n\n  mapIntegersToDayMonth(integers) {\n    const temp = [integers, integers.slice().reverse()];\n\n    for (let i = 0; i < temp.length; i += 1) {\n      const data = temp[i];\n      const day = data[0];\n      const month = data[1];\n\n      if (day >= 1 && day <= 31 && month >= 1 && month <= 12) {\n        return {\n          day,\n          month\n        };\n      }\n    }\n\n    return null;\n  }\n\n  twoToFourDigitYear(year) {\n    if (year > 99) {\n      return year;\n    }\n\n    if (year > 50) {\n      // 87 -> 1987\n      return year + 1900;\n    } // 15 -> 2015\n\n\n    return year + 2000;\n  }\n\n}\n\nexport { MatchDate as default };\n//# sourceMappingURL=matching.esm.js.map\n","var l33tTable = {\n  a: ['4', '@'],\n  b: ['8'],\n  c: ['(', '{', '[', '<'],\n  e: ['3'],\n  g: ['6', '9'],\n  i: ['1', '!', '|'],\n  l: ['1', '|', '7'],\n  o: ['0'],\n  s: ['$', '5'],\n  t: ['+', '7'],\n  x: ['%'],\n  z: ['2']\n};\n\nexport { l33tTable as default };\n//# sourceMappingURL=l33tTable.esm.js.map\n","var translationKeys = {\n  warnings: {\n    straightRow: 'straightRow',\n    keyPattern: 'keyPattern',\n    simpleRepeat: 'simpleRepeat',\n    extendedRepeat: 'extendedRepeat',\n    sequences: 'sequences',\n    recentYears: 'recentYears',\n    dates: 'dates',\n    topTen: 'topTen',\n    topHundred: 'topHundred',\n    common: 'common',\n    similarToCommon: 'similarToCommon',\n    wordByItself: 'wordByItself',\n    namesByThemselves: 'namesByThemselves',\n    commonNames: 'commonNames',\n    userInputs: 'userInputs'\n  },\n  suggestions: {\n    l33t: 'l33t',\n    reverseWords: 'reverseWords',\n    allUppercase: 'allUppercase',\n    capitalization: 'capitalization',\n    dates: 'dates',\n    recentYears: 'recentYears',\n    associatedYears: 'associatedYears',\n    sequences: 'sequences',\n    repeated: 'repeated',\n    longerKeyboardPattern: 'longerKeyboardPattern',\n    anotherWord: 'anotherWord',\n    useWords: 'useWords',\n    noNeed: 'noNeed'\n  },\n  timeEstimation: {\n    ltSecond: 'ltSecond',\n    second: 'second',\n    seconds: 'seconds',\n    minute: 'minute',\n    minutes: 'minutes',\n    hour: 'hour',\n    hours: 'hours',\n    day: 'day',\n    days: 'days',\n    month: 'month',\n    months: 'months',\n    year: 'year',\n    years: 'years',\n    centuries: 'centuries'\n  }\n};\n\nexport { translationKeys as default };\n//# sourceMappingURL=translationKeys.esm.js.map\n","import { buildRankedDictionary } from './helper.esm.js';\nimport l33tTable from './data/l33tTable.esm.js';\nimport translationKeys from './data/translationKeys.esm.js';\n\nclass Options {\n  constructor() {\n    this.matchers = {};\n    this.l33tTable = l33tTable;\n    this.dictionary = {\n      userInputs: []\n    };\n    this.rankedDictionaries = {};\n    this.translations = translationKeys;\n    this.graphs = {};\n    this.availableGraphs = [];\n    this.setRankedDictionaries();\n  }\n\n  setOptions(options = {}) {\n    if (options.l33tTable) {\n      this.l33tTable = options.l33tTable;\n    }\n\n    if (options.dictionary) {\n      this.dictionary = options.dictionary;\n      this.setRankedDictionaries();\n    }\n\n    if (options.translations) {\n      this.setTranslations(options.translations);\n    }\n\n    if (options.graphs) {\n      this.graphs = options.graphs;\n    }\n  }\n\n  setTranslations(translations) {\n    if (this.checkCustomTranslations(translations)) {\n      this.translations = translations;\n    } else {\n      throw new Error('Invalid translations object fallback to keys');\n    }\n  }\n\n  checkCustomTranslations(translations) {\n    let valid = true;\n    Object.keys(translationKeys).forEach(type => {\n      if (type in translations) {\n        const translationType = type;\n        Object.keys(translationKeys[translationType]).forEach(key => {\n          if (!(key in translations[translationType])) {\n            valid = false;\n          }\n        });\n      } else {\n        valid = false;\n      }\n    });\n    return valid;\n  }\n\n  setRankedDictionaries() {\n    const rankedDictionaries = {};\n    Object.keys(this.dictionary).forEach(name => {\n      rankedDictionaries[name] = this.getRankedDictionary(name);\n    });\n    this.rankedDictionaries = rankedDictionaries;\n  }\n\n  getRankedDictionary(name) {\n    const list = this.dictionary[name];\n\n    if (name === 'userInputs') {\n      const sanitizedInputs = [];\n      list.forEach(input => {\n        const inputType = typeof input;\n\n        if (inputType === 'string' || inputType === 'number' || inputType === 'boolean') {\n          sanitizedInputs.push(input.toString().toLowerCase());\n        }\n      });\n      return buildRankedDictionary(sanitizedInputs);\n    }\n\n    return buildRankedDictionary(list);\n  }\n\n  extendUserInputsDictionary(dictionary) {\n    if (this.dictionary.userInputs) {\n      this.dictionary.userInputs = [...this.dictionary.userInputs, ...dictionary];\n    } else {\n      this.dictionary.userInputs = dictionary;\n    }\n\n    this.rankedDictionaries.userInputs = this.getRankedDictionary('userInputs');\n  }\n\n  addMatcher(name, matcher) {\n    if (this.matchers[name]) {\n      console.info('Matcher already exists');\n    } else {\n      this.matchers[name] = matcher;\n    }\n  }\n\n}\n\nvar Options$1 = new Options();\n\nexport { Options$1 as default };\n//# sourceMappingURL=Options.esm.js.map\n","/*\n * -------------------------------------------------------------------------------\n *  Dictionary reverse matching --------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchL33t {\n  constructor(defaultMatch) {\n    this.defaultMatch = defaultMatch;\n  }\n\n  match({\n    password\n  }) {\n    const passwordReversed = password.split('').reverse().join('');\n    return this.defaultMatch({\n      password: passwordReversed\n    }).map(match => ({ ...match,\n      token: match.token.split('').reverse().join(''),\n      reversed: true,\n      // map coordinates back to original string\n      i: password.length - 1 - match.j,\n      j: password.length - 1 - match.i\n    }));\n  }\n\n}\n\nexport { MatchL33t as default };\n//# sourceMappingURL=reverse.esm.js.map\n","import { empty, translate } from '../../../../helper.esm.js';\nimport Options from '../../../../Options.esm.js';\n\n/*\n * -------------------------------------------------------------------------------\n *  Dictionary l33t matching -----------------------------------------------------\n * -------------------------------------------------------------------------------\n */\n\nclass MatchL33t {\n  constructor(defaultMatch) {\n    this.defaultMatch = defaultMatch;\n  }\n\n  match({\n    password\n  }) {\n    const matches = [];\n    const enumeratedSubs = this.enumerateL33tSubs(this.relevantL33tSubtable(password, Options.l33tTable));\n\n    for (let i = 0; i < enumeratedSubs.length; i += 1) {\n      const sub = enumeratedSubs[i]; // corner case: password has no relevant subs.\n\n      if (empty(sub)) {\n        break;\n      }\n\n      const subbedPassword = translate(password, sub);\n      const matchedDictionary = this.defaultMatch({\n        password: subbedPassword\n      });\n      matchedDictionary.forEach(match => {\n        const token = password.slice(match.i, +match.j + 1 || 9e9); // only return the matches that contain an actual substitution\n\n        if (token.toLowerCase() !== match.matchedWord) {\n          // subset of mappings in sub that are in use for this match\n          const matchSub = {};\n          Object.keys(sub).forEach(subbedChr => {\n            const chr = sub[subbedChr];\n\n            if (token.indexOf(subbedChr) !== -1) {\n              matchSub[subbedChr] = chr;\n            }\n          });\n          const subDisplay = Object.keys(matchSub).map(k => `${k} -> ${matchSub[k]}`).join(', ');\n          matches.push({ ...match,\n            l33t: true,\n            token,\n            sub: matchSub,\n            subDisplay\n          });\n        }\n      });\n    } // filter single-character l33t matches to reduce noise.\n    // otherwise '1' matches 'i', '4' matches 'a', both very common English words\n    // with low dictionary rank.\n\n\n    return matches.filter(match => match.token.length > 1);\n  } // makes a pruned copy of l33t_table that only includes password's possible substitutions\n\n\n  relevantL33tSubtable(password, table) {\n    const passwordChars = {};\n    const subTable = {};\n    password.split('').forEach(char => {\n      passwordChars[char] = true;\n    });\n    Object.keys(table).forEach(letter => {\n      const subs = table[letter];\n      const relevantSubs = subs.filter(sub => sub in passwordChars);\n\n      if (relevantSubs.length > 0) {\n        subTable[letter] = relevantSubs;\n      }\n    });\n    return subTable;\n  } // returns the list of possible 1337 replacement dictionaries for a given password\n\n\n  enumerateL33tSubs(table) {\n    const tableKeys = Object.keys(table);\n    const subs = this.getSubs(tableKeys, [[]], table); // convert from assoc lists to dicts\n\n    return subs.map(sub => {\n      const subDict = {};\n      sub.forEach(([l33tChr, chr]) => {\n        subDict[l33tChr] = chr;\n      });\n      return subDict;\n    });\n  }\n\n  getSubs(keys, subs, table) {\n    if (!keys.length) {\n      return subs;\n    }\n\n    const firstKey = keys[0];\n    const restKeys = keys.slice(1);\n    const nextSubs = [];\n    table[firstKey].forEach(l33tChr => {\n      subs.forEach(sub => {\n        let dupL33tIndex = -1;\n\n        for (let i = 0; i < sub.length; i += 1) {\n          if (sub[i][0] === l33tChr) {\n            dupL33tIndex = i;\n            break;\n          }\n        }\n\n        if (dupL33tIndex === -1) {\n          const subExtension = sub.concat([[l33tChr, firstKey]]);\n          nextSubs.push(subExtension);\n        } else {\n          const subAlternative = sub.slice(0);\n          subAlternative.splice(dupL33tIndex, 1);\n          subAlternative.push([l33tChr, firstKey]);\n          nextSubs.push(sub);\n          nextSubs.push(subAlternative);\n        }\n      });\n    });\n    const newSubs = this.dedup(nextSubs);\n\n    if (restKeys.length) {\n      return this.getSubs(restKeys, newSubs, table);\n    }\n\n    return newSubs;\n  }\n\n  dedup(subs) {\n    const deduped = [];\n    const members = {};\n    subs.forEach(sub => {\n      const assoc = sub.map((k, index) => [k, index]);\n      assoc.sort();\n      const label = assoc.map(([k, v]) => `${k},${v}`).join('-');\n\n      if (!(label in members)) {\n        members[label] = true;\n        deduped.push(sub);\n      }\n    });\n    return deduped;\n  }\n\n}\n\nexport { MatchL33t as default };\n//# sourceMappingURL=l33t.esm.js.map\n","import { sorted } from '../../helper.esm.js';\nimport Options from '../../Options.esm.js';\nimport MatchL33t$1 from './variants/matching/reverse.esm.js';\nimport MatchL33t from './variants/matching/l33t.esm.js';\n\nclass MatchDictionary {\n  constructor() {\n    this.l33t = new MatchL33t(this.defaultMatch);\n    this.reverse = new MatchL33t$1(this.defaultMatch);\n  }\n\n  match({\n    password\n  }) {\n    const matches = [...this.defaultMatch({\n      password\n    }), ...this.reverse.match({\n      password\n    }), ...this.l33t.match({\n      password\n    })];\n    return sorted(matches);\n  }\n\n  defaultMatch({\n    password\n  }) {\n    // rankedDictionaries variable is for unit testing purposes\n    const matches = [];\n    const passwordLength = password.length;\n    const passwordLower = password.toLowerCase();\n    Object.keys(Options.rankedDictionaries).forEach(dictionaryName => {\n      const rankedDict = Options.rankedDictionaries[dictionaryName];\n\n      for (let i = 0; i < passwordLength; i += 1) {\n        for (let j = i; j < passwordLength; j += 1) {\n          if (passwordLower.slice(i, +j + 1 || 9e9) in rankedDict) {\n            const word = passwordLower.slice(i, +j + 1 || 9e9);\n            const rank = rankedDict[word];\n            matches.push({\n              pattern: 'dictionary',\n              i,\n              j,\n              token: password.slice(i, +j + 1 || 9e9),\n              matchedWord: word,\n              rank,\n              dictionaryName: dictionaryName,\n              reversed: false,\n              l33t: false\n            });\n          }\n        }\n      }\n    });\n    return matches;\n  }\n\n}\n\nexport { MatchDictionary as default };\n//# sourceMappingURL=matching.esm.js.map\n","import { REGEXEN } from '../../data/const.esm.js';\nimport { sorted } from '../../helper.esm.js';\n\n/*\n * -------------------------------------------------------------------------------\n *  regex matching ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\n\nclass MatchRegex {\n  match({\n    password,\n    regexes = REGEXEN\n  }) {\n    const matches = [];\n    Object.keys(regexes).forEach(name => {\n      const regex = regexes[name];\n      regex.lastIndex = 0; // keeps regexMatch stateless\n\n      const regexMatch = regex.exec(password);\n\n      if (regexMatch) {\n        const token = regexMatch[0];\n        matches.push({\n          pattern: 'regex',\n          token,\n          i: regexMatch.index,\n          j: regexMatch.index + regexMatch[0].length - 1,\n          regexName: name,\n          regexMatch\n        });\n      }\n    });\n    return sorted(matches);\n  }\n\n}\n\nexport { MatchRegex as default };\n//# sourceMappingURL=matching.esm.js.map\n","var utils = {\n  // binomial coefficients\n  // src: http://blog.plover.com/math/choose.html\n  nCk(n, k) {\n    let count = n;\n\n    if (k > count) {\n      return 0;\n    }\n\n    if (k === 0) {\n      return 1;\n    }\n\n    let coEff = 1;\n\n    for (let i = 1; i <= k; i += 1) {\n      coEff *= count;\n      coEff /= i;\n      count -= 1;\n    }\n\n    return coEff;\n  },\n\n  log10(n) {\n    return Math.log(n) / Math.log(10); // IE doesn't support Math.log10 :(\n  },\n\n  log2(n) {\n    return Math.log(n) / Math.log(2);\n  },\n\n  factorial(num) {\n    let rval = 1;\n\n    for (let i = 2; i <= num; i += 1) rval *= i;\n\n    return rval;\n  }\n\n};\n\nexport { utils as default };\n//# sourceMappingURL=utils.esm.js.map\n","import { MIN_SUBMATCH_GUESSES_SINGLE_CHAR, MIN_SUBMATCH_GUESSES_MULTI_CHAR } from '../data/const.esm.js';\nimport utils from './utils.esm.js';\nimport Options from '../Options.esm.js';\nimport bruteforceMatcher from '../matcher/bruteforce/scoring.esm.js';\nimport dateMatcher from '../matcher/date/scoring.esm.js';\nimport dictionaryMatcher from '../matcher/dictionary/scoring.esm.js';\nimport regexMatcher from '../matcher/regex/scoring.esm.js';\nimport repeatMatcher from '../matcher/repeat/scoring.esm.js';\nimport sequenceMatcher from '../matcher/sequence/scoring.esm.js';\nimport spatialMatcher from '../matcher/spatial/scoring.esm.js';\n\nconst getMinGuesses = (match, password) => {\n  let minGuesses = 1;\n\n  if (match.token.length < password.length) {\n    if (match.token.length === 1) {\n      minGuesses = MIN_SUBMATCH_GUESSES_SINGLE_CHAR;\n    } else {\n      minGuesses = MIN_SUBMATCH_GUESSES_MULTI_CHAR;\n    }\n  }\n\n  return minGuesses;\n};\n\nconst matchers = {\n  bruteforce: bruteforceMatcher,\n  date: dateMatcher,\n  dictionary: dictionaryMatcher,\n  regex: regexMatcher,\n  repeat: repeatMatcher,\n  sequence: sequenceMatcher,\n  spatial: spatialMatcher\n};\n\nconst getScoring = (name, match) => {\n  if (matchers[name]) {\n    return matchers[name](match);\n  }\n\n  if (Options.matchers[name] && 'scoring' in Options.matchers[name]) {\n    return Options.matchers[name].scoring(match);\n  }\n\n  return 0;\n}; // ------------------------------------------------------------------------------\n// guess estimation -- one function per match pattern ---------------------------\n// ------------------------------------------------------------------------------\n\n\nvar estimateGuesses = ((match, password) => {\n  const extraData = {}; // a match's guess estimate doesn't change. cache it.\n\n  if ('guesses' in match && match.guesses != null) {\n    return match;\n  }\n\n  const minGuesses = getMinGuesses(match, password);\n  const estimationResult = getScoring(match.pattern, match);\n  let guesses = 0;\n\n  if (typeof estimationResult === 'number') {\n    guesses = estimationResult;\n  } else if (match.pattern === 'dictionary') {\n    guesses = estimationResult.calculation;\n    extraData.baseGuesses = estimationResult.baseGuesses;\n    extraData.uppercaseVariations = estimationResult.uppercaseVariations;\n    extraData.l33tVariations = estimationResult.l33tVariations;\n  }\n\n  const matchGuesses = Math.max(guesses, minGuesses);\n  return { ...match,\n    ...extraData,\n    guesses: matchGuesses,\n    guessesLog10: utils.log10(matchGuesses)\n  };\n});\n\nexport { estimateGuesses as default };\n//# sourceMappingURL=estimate.esm.js.map\n","import { BRUTEFORCE_CARDINALITY, MIN_SUBMATCH_GUESSES_SINGLE_CHAR, MIN_SUBMATCH_GUESSES_MULTI_CHAR } from '../../data/const.esm.js';\n\nvar bruteforceMatcher = (({\n  token\n}) => {\n  let guesses = BRUTEFORCE_CARDINALITY ** token.length;\n\n  if (guesses === Number.POSITIVE_INFINITY) {\n    guesses = Number.MAX_VALUE;\n  }\n\n  let minGuesses; // small detail: make bruteforce matches at minimum one guess bigger than smallest allowed\n  // submatch guesses, such that non-bruteforce submatches over the same [i..j] take precedence.\n\n  if (token.length === 1) {\n    minGuesses = MIN_SUBMATCH_GUESSES_SINGLE_CHAR + 1;\n  } else {\n    minGuesses = MIN_SUBMATCH_GUESSES_MULTI_CHAR + 1;\n  }\n\n  return Math.max(guesses, minGuesses);\n});\n\nexport { bruteforceMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","import { REFERENCE_YEAR, MIN_YEAR_SPACE } from '../../data/const.esm.js';\n\nvar dateMatcher = (({\n  year,\n  separator\n}) => {\n  // base guesses: (year distance from REFERENCE_YEAR) * num_days * num_years\n  const yearSpace = Math.max(Math.abs(year - REFERENCE_YEAR), MIN_YEAR_SPACE);\n  let guesses = yearSpace * 365; // add factor of 4 for separator selection (one of ~4 choices)\n\n  if (separator) {\n    guesses *= 4;\n  }\n\n  return guesses;\n});\n\nexport { dateMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","import uppercaseVariant from './variants/scoring/uppercase.esm.js';\nimport l33tVariant from './variants/scoring/l33t.esm.js';\n\nvar dictionaryMatcher = (({\n  rank,\n  reversed,\n  l33t,\n  sub,\n  token\n}) => {\n  const baseGuesses = rank; // keep these as properties for display purposes\n\n  const uppercaseVariations = uppercaseVariant(token);\n  const l33tVariations = l33tVariant({\n    l33t,\n    sub,\n    token\n  });\n  const reversedVariations = reversed && 2 || 1;\n  const calculation = baseGuesses * uppercaseVariations * l33tVariations * reversedVariations;\n  return {\n    baseGuesses,\n    uppercaseVariations,\n    l33tVariations,\n    calculation\n  };\n});\n\nexport { dictionaryMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","import utils from '../../../../scoring/utils.esm.js';\nimport { ALPHA_INVERTED, ALL_LOWER_INVERTED, ONE_UPPER, ONE_LOWER, START_UPPER, END_UPPER, ALL_UPPER_INVERTED } from '../../../../data/const.esm.js';\n\nconst getVariations = cleanedWord => {\n  const wordArray = cleanedWord.split('');\n  const upperCaseCount = wordArray.filter(char => char.match(ONE_UPPER)).length;\n  const lowerCaseCount = wordArray.filter(char => char.match(ONE_LOWER)).length;\n  let variations = 0;\n  const variationLength = Math.min(upperCaseCount, lowerCaseCount);\n\n  for (let i = 1; i <= variationLength; i += 1) {\n    variations += utils.nCk(upperCaseCount + lowerCaseCount, i);\n  }\n\n  return variations;\n};\n\nvar uppercaseVariant = (word => {\n  // clean words of non alpha characters to remove the reward effekt to capitalize the first letter https://github.com/dropbox/zxcvbn/issues/232\n  const cleanedWord = word.replace(ALPHA_INVERTED, '');\n\n  if (cleanedWord.match(ALL_LOWER_INVERTED) || cleanedWord.toLowerCase() === cleanedWord) {\n    return 1;\n  } // a capitalized word is the most common capitalization scheme,\n  // so it only doubles the search space (uncapitalized + capitalized).\n  // all caps and end-capitalized are common enough too, underestimate as 2x factor to be safe.\n\n\n  const commonCases = [START_UPPER, END_UPPER, ALL_UPPER_INVERTED];\n  const commonCasesLength = commonCases.length;\n\n  for (let i = 0; i < commonCasesLength; i += 1) {\n    const regex = commonCases[i];\n\n    if (cleanedWord.match(regex)) {\n      return 2;\n    }\n  } // otherwise calculate the number of ways to capitalize U+L uppercase+lowercase letters\n  // with U uppercase letters or less. or, if there's more uppercase than lower (for eg. PASSwORD),\n  // the number of ways to lowercase U+L letters with L lowercase letters or less.\n\n\n  return getVariations(cleanedWord);\n});\n\nexport { uppercaseVariant as default };\n//# sourceMappingURL=uppercase.esm.js.map\n","import utils from '../../../../scoring/utils.esm.js';\n\nconst getCounts = ({\n  subs,\n  subbed,\n  token\n}) => {\n  const unsubbed = subs[subbed]; // lower-case match.token before calculating: capitalization shouldn't affect l33t calc.\n\n  const chrs = token.toLowerCase().split(''); // num of subbed chars\n\n  const subbedCount = chrs.filter(char => char === subbed).length; // num of unsubbed chars\n\n  const unsubbedCount = chrs.filter(char => char === unsubbed).length;\n  return {\n    subbedCount,\n    unsubbedCount\n  };\n};\n\nvar l33tVariant = (({\n  l33t,\n  sub,\n  token\n}) => {\n  if (!l33t) {\n    return 1;\n  }\n\n  let variations = 1;\n  const subs = sub;\n  Object.keys(subs).forEach(subbed => {\n    const {\n      subbedCount,\n      unsubbedCount\n    } = getCounts({\n      subs,\n      subbed,\n      token\n    });\n\n    if (subbedCount === 0 || unsubbedCount === 0) {\n      // for this sub, password is either fully subbed (444) or fully unsubbed (aaa)\n      // treat that as doubling the space (attacker needs to try fully subbed chars in addition to\n      // unsubbed.)\n      variations *= 2;\n    } else {\n      // this case is similar to capitalization:\n      // with aa44a, U = 3, S = 2, attacker needs to try unsubbed + one sub + two subs\n      const p = Math.min(unsubbedCount, subbedCount);\n      let possibilities = 0;\n\n      for (let i = 1; i <= p; i += 1) {\n        possibilities += utils.nCk(unsubbedCount + subbedCount, i);\n      }\n\n      variations *= possibilities;\n    }\n  });\n  return variations;\n});\n\nexport { l33tVariant as default };\n//# sourceMappingURL=l33t.esm.js.map\n","import { REFERENCE_YEAR, MIN_YEAR_SPACE } from '../../data/const.esm.js';\n\nvar regexMatcher = (({\n  regexName,\n  regexMatch,\n  token\n}) => {\n  const charClassBases = {\n    alphaLower: 26,\n    alphaUpper: 26,\n    alpha: 52,\n    alphanumeric: 62,\n    digits: 10,\n    symbols: 33\n  };\n\n  if (regexName in charClassBases) {\n    return charClassBases[regexName] ** token.length;\n  } // TODO add more regex types for example special dates like 09.11\n  // eslint-disable-next-line default-case\n\n\n  switch (regexName) {\n    case 'recentYear':\n      // conservative estimate of year space: num years from REFERENCE_YEAR.\n      // if year is close to REFERENCE_YEAR, estimate a year space of MIN_YEAR_SPACE.\n      return Math.max(Math.abs(parseInt(regexMatch[0], 10) - REFERENCE_YEAR), MIN_YEAR_SPACE);\n  }\n\n  return 0;\n});\n\nexport { regexMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","var repeatMatcher = (({\n  baseGuesses,\n  repeatCount\n}) => baseGuesses * repeatCount);\n\nexport { repeatMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","var sequenceMatcher = (({\n  token,\n  ascending\n}) => {\n  const firstChr = token.charAt(0);\n  let baseGuesses = 0;\n  const startingPoints = ['a', 'A', 'z', 'Z', '0', '1', '9']; // lower guesses for obvious starting points\n\n  if (startingPoints.includes(firstChr)) {\n    baseGuesses = 4;\n  } else if (firstChr.match(/\\d/)) {\n    baseGuesses = 10; // digits\n  } else {\n    // could give a higher base for uppercase,\n    // assigning 26 to both upper and lower sequences is more conservative.\n    baseGuesses = 26;\n  } // need to try a descending sequence in addition to every ascending sequence ->\n  // 2x guesses\n\n\n  if (!ascending) {\n    baseGuesses *= 2;\n  }\n\n  return baseGuesses * token.length;\n});\n\nexport { sequenceMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","import utils from '../../scoring/utils.esm.js';\nimport Options from '../../Options.esm.js';\n\nconst calcAverageDegree = graph => {\n  let average = 0;\n  Object.keys(graph).forEach(key => {\n    const neighbors = graph[key];\n    average += neighbors.filter(entry => !!entry).length;\n  });\n  average /= Object.entries(graph).length;\n  return average;\n};\n\nconst estimatePossiblePatterns = ({\n  token,\n  graph,\n  turns\n}) => {\n  const startingPosition = Object.keys(Options.graphs[graph]).length;\n  const averageDegree = calcAverageDegree(Options.graphs[graph]);\n  let guesses = 0;\n  const tokenLength = token.length; // # estimate the number of possible patterns w/ tokenLength or less with turns or less.\n\n  for (let i = 2; i <= tokenLength; i += 1) {\n    const possibleTurns = Math.min(turns, i - 1);\n\n    for (let j = 1; j <= possibleTurns; j += 1) {\n      guesses += utils.nCk(i - 1, j - 1) * startingPosition * averageDegree ** j;\n    }\n  }\n\n  return guesses;\n};\n\nvar spatialMatcher = (({\n  graph,\n  token,\n  shiftedCount,\n  turns\n}) => {\n  let guesses = estimatePossiblePatterns({\n    token,\n    graph,\n    turns\n  }); // add extra guesses for shifted keys. (% instead of 5, A instead of a.)\n  // math is similar to extra guesses of l33t substitutions in dictionary matches.\n\n  if (shiftedCount) {\n    const unShiftedCount = token.length - shiftedCount;\n\n    if (shiftedCount === 0 || unShiftedCount === 0) {\n      guesses *= 2;\n    } else {\n      let shiftedVariations = 0;\n\n      for (let i = 1; i <= Math.min(shiftedCount, unShiftedCount); i += 1) {\n        shiftedVariations += utils.nCk(shiftedCount + unShiftedCount, i);\n      }\n\n      guesses *= shiftedVariations;\n    }\n  }\n\n  return Math.round(guesses);\n});\n\nexport { spatialMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","import utils from './utils.esm.js';\nimport estimateGuesses from './estimate.esm.js';\nimport { MIN_GUESSES_BEFORE_GROWING_SEQUENCE } from '../data/const.esm.js';\n\nconst scoringHelper = {\n  password: '',\n  optimal: {},\n  excludeAdditive: false,\n\n  fillArray(size, valueType) {\n    const result = [];\n\n    for (let i = 0; i < size; i += 1) {\n      let value = [];\n\n      if (valueType === 'object') {\n        value = {};\n      }\n\n      result.push(value);\n    }\n\n    return result;\n  },\n\n  // helper: make bruteforce match objects spanning i to j, inclusive.\n  makeBruteforceMatch(i, j) {\n    return {\n      pattern: 'bruteforce',\n      token: this.password.slice(i, +j + 1 || 9e9),\n      i,\n      j\n    };\n  },\n\n  // helper: considers whether a length-sequenceLength\n  // sequence ending at match m is better (fewer guesses)\n  // than previously encountered sequences, updating state if so.\n  update(match, sequenceLength) {\n    const k = match.j;\n    const estimatedMatch = estimateGuesses(match, this.password);\n    let pi = estimatedMatch.guesses;\n\n    if (sequenceLength > 1) {\n      // we're considering a length-sequenceLength sequence ending with match m:\n      // obtain the product term in the minimization function by multiplying m's guesses\n      // by the product of the length-(sequenceLength-1)\n      // sequence ending just before m, at m.i - 1.\n      pi *= this.optimal.pi[estimatedMatch.i - 1][sequenceLength - 1];\n    } // calculate the minimization func\n\n\n    let g = utils.factorial(sequenceLength) * pi;\n\n    if (!this.excludeAdditive) {\n      g += MIN_GUESSES_BEFORE_GROWING_SEQUENCE ** (sequenceLength - 1);\n    } // update state if new best.\n    // first see if any competing sequences covering this prefix,\n    // with sequenceLength or fewer matches,\n    // fare better than this sequence. if so, skip it and return.\n\n\n    let shouldSkip = false;\n    Object.keys(this.optimal.g[k]).forEach(competingPatternLength => {\n      const competingMetricMatch = this.optimal.g[k][competingPatternLength];\n\n      if (parseInt(competingPatternLength, 10) <= sequenceLength) {\n        if (competingMetricMatch <= g) {\n          shouldSkip = true;\n        }\n      }\n    });\n\n    if (!shouldSkip) {\n      // this sequence might be part of the final optimal sequence.\n      this.optimal.g[k][sequenceLength] = g;\n      this.optimal.m[k][sequenceLength] = estimatedMatch;\n      this.optimal.pi[k][sequenceLength] = pi;\n    }\n  },\n\n  // helper: evaluate bruteforce matches ending at passwordCharIndex.\n  bruteforceUpdate(passwordCharIndex) {\n    // see if a single bruteforce match spanning the passwordCharIndex-prefix is optimal.\n    let match = this.makeBruteforceMatch(0, passwordCharIndex);\n    this.update(match, 1);\n\n    for (let i = 1; i <= passwordCharIndex; i += 1) {\n      // generate passwordCharIndex bruteforce matches, spanning from (i=1, j=passwordCharIndex) up to (i=passwordCharIndex, j=passwordCharIndex).\n      // see if adding these new matches to any of the sequences in optimal[i-1]\n      // leads to new bests.\n      match = this.makeBruteforceMatch(i, passwordCharIndex);\n      const tmp = this.optimal.m[i - 1]; // eslint-disable-next-line no-loop-func\n\n      Object.keys(tmp).forEach(sequenceLength => {\n        const lastMatch = tmp[sequenceLength]; // corner: an optimal sequence will never have two adjacent bruteforce matches.\n        // it is strictly better to have a single bruteforce match spanning the same region:\n        // same contribution to the guess product with a lower length.\n        // --> safe to skip those cases.\n\n        if (lastMatch.pattern !== 'bruteforce') {\n          // try adding m to this length-sequenceLength sequence.\n          this.update(match, parseInt(sequenceLength, 10) + 1);\n        }\n      });\n    }\n  },\n\n  // helper: step backwards through optimal.m starting at the end,\n  // constructing the final optimal match sequence.\n  unwind(passwordLength) {\n    const optimalMatchSequence = [];\n    let k = passwordLength - 1; // find the final best sequence length and score\n\n    let sequenceLength = 0; // eslint-disable-next-line no-loss-of-precision\n\n    let g = 2e308;\n    const temp = this.optimal.g[k]; // safety check for empty passwords\n\n    if (temp) {\n      Object.keys(temp).forEach(candidateSequenceLength => {\n        const candidateMetricMatch = temp[candidateSequenceLength];\n\n        if (candidateMetricMatch < g) {\n          sequenceLength = parseInt(candidateSequenceLength, 10);\n          g = candidateMetricMatch;\n        }\n      });\n    }\n\n    while (k >= 0) {\n      const match = this.optimal.m[k][sequenceLength];\n      optimalMatchSequence.unshift(match);\n      k = match.i - 1;\n      sequenceLength -= 1;\n    }\n\n    return optimalMatchSequence;\n  }\n\n};\nvar scoring = {\n  // ------------------------------------------------------------------------------\n  // search --- most guessable match sequence -------------------------------------\n  // ------------------------------------------------------------------------------\n  //\n  // takes a sequence of overlapping matches, returns the non-overlapping sequence with\n  // minimum guesses. the following is a O(l_max * (n + m)) dynamic programming algorithm\n  // for a length-n password with m candidate matches. l_max is the maximum optimal\n  // sequence length spanning each prefix of the password. In practice it rarely exceeds 5 and the\n  // search terminates rapidly.\n  //\n  // the optimal \"minimum guesses\" sequence is here defined to be the sequence that\n  // minimizes the following function:\n  //\n  //    g = sequenceLength! * Product(m.guesses for m in sequence) + D^(sequenceLength - 1)\n  //\n  // where sequenceLength is the length of the sequence.\n  //\n  // the factorial term is the number of ways to order sequenceLength patterns.\n  //\n  // the D^(sequenceLength-1) term is another length penalty, roughly capturing the idea that an\n  // attacker will try lower-length sequences first before trying length-sequenceLength sequences.\n  //\n  // for example, consider a sequence that is date-repeat-dictionary.\n  //  - an attacker would need to try other date-repeat-dictionary combinations,\n  //    hence the product term.\n  //  - an attacker would need to try repeat-date-dictionary, dictionary-repeat-date,\n  //    ..., hence the factorial term.\n  //  - an attacker would also likely try length-1 (dictionary) and length-2 (dictionary-date)\n  //    sequences before length-3. assuming at minimum D guesses per pattern type,\n  //    D^(sequenceLength-1) approximates Sum(D^i for i in [1..sequenceLength-1]\n  //\n  // ------------------------------------------------------------------------------\n  mostGuessableMatchSequence(password, matches, excludeAdditive = false) {\n    scoringHelper.password = password;\n    scoringHelper.excludeAdditive = excludeAdditive;\n    const passwordLength = password.length; // partition matches into sublists according to ending index j\n\n    let matchesByCoordinateJ = scoringHelper.fillArray(passwordLength, 'array');\n    matches.forEach(match => {\n      matchesByCoordinateJ[match.j].push(match);\n    }); // small detail: for deterministic output, sort each sublist by i.\n\n    matchesByCoordinateJ = matchesByCoordinateJ.map(match => match.sort((m1, m2) => m1.i - m2.i));\n    scoringHelper.optimal = {\n      // optimal.m[k][sequenceLength] holds final match in the best length-sequenceLength\n      // match sequence covering the\n      // password prefix up to k, inclusive.\n      // if there is no length-sequenceLength sequence that scores better (fewer guesses) than\n      // a shorter match sequence spanning the same prefix,\n      // optimal.m[k][sequenceLength] is undefined.\n      m: scoringHelper.fillArray(passwordLength, 'object'),\n      // same structure as optimal.m -- holds the product term Prod(m.guesses for m in sequence).\n      // optimal.pi allows for fast (non-looping) updates to the minimization function.\n      pi: scoringHelper.fillArray(passwordLength, 'object'),\n      // same structure as optimal.m -- holds the overall metric.\n      g: scoringHelper.fillArray(passwordLength, 'object')\n    };\n\n    for (let k = 0; k < passwordLength; k += 1) {\n      matchesByCoordinateJ[k].forEach(match => {\n        if (match.i > 0) {\n          Object.keys(scoringHelper.optimal.m[match.i - 1]).forEach(sequenceLength => {\n            scoringHelper.update(match, parseInt(sequenceLength, 10) + 1);\n          });\n        } else {\n          scoringHelper.update(match, 1);\n        }\n      });\n      scoringHelper.bruteforceUpdate(k);\n    }\n\n    const optimalMatchSequence = scoringHelper.unwind(passwordLength);\n    const optimalSequenceLength = optimalMatchSequence.length;\n    const guesses = this.getGuesses(password, optimalSequenceLength);\n    return {\n      password,\n      guesses,\n      guessesLog10: utils.log10(guesses),\n      sequence: optimalMatchSequence\n    };\n  },\n\n  getGuesses(password, optimalSequenceLength) {\n    const passwordLength = password.length;\n    let guesses = 0;\n\n    if (password.length === 0) {\n      guesses = 1;\n    } else {\n      guesses = scoringHelper.optimal.g[passwordLength - 1][optimalSequenceLength];\n    }\n\n    return guesses;\n  }\n\n};\n\nexport { scoring as default };\n//# sourceMappingURL=index.esm.js.map\n","import scoring from '../../scoring/index.esm.js';\n\n/*\n *-------------------------------------------------------------------------------\n * repeats (aaa, abcabcabc) ------------------------------\n *-------------------------------------------------------------------------------\n */\n\nclass MatchRepeat {\n  // eslint-disable-next-line max-statements\n  match({\n    password,\n    omniMatch\n  }) {\n    const matches = [];\n    let lastIndex = 0;\n\n    while (lastIndex < password.length) {\n      const greedyMatch = this.getGreedyMatch(password, lastIndex);\n      const lazyMatch = this.getLazyMatch(password, lastIndex);\n\n      if (greedyMatch == null) {\n        break;\n      }\n\n      const {\n        match,\n        baseToken\n      } = this.setMatchToken(greedyMatch, lazyMatch);\n\n      if (match) {\n        const j = match.index + match[0].length - 1;\n        const baseGuesses = this.getBaseGuesses(baseToken, omniMatch);\n        matches.push(this.normalizeMatch(baseToken, j, match, baseGuesses));\n        lastIndex = j + 1;\n      }\n    }\n\n    const hasPromises = matches.some(match => {\n      return match instanceof Promise;\n    });\n\n    if (hasPromises) {\n      return Promise.all(matches);\n    }\n\n    return matches;\n  } // eslint-disable-next-line max-params\n\n\n  normalizeMatch(baseToken, j, match, baseGuesses) {\n    const baseMatch = {\n      pattern: 'repeat',\n      i: match.index,\n      j,\n      token: match[0],\n      baseToken,\n      baseGuesses: 0,\n      repeatCount: match[0].length / baseToken.length\n    };\n\n    if (baseGuesses instanceof Promise) {\n      return baseGuesses.then(resolvedBaseGuesses => {\n        return { ...baseMatch,\n          baseGuesses: resolvedBaseGuesses\n        };\n      });\n    }\n\n    return { ...baseMatch,\n      baseGuesses\n    };\n  }\n\n  getGreedyMatch(password, lastIndex) {\n    const greedy = /(.+)\\1+/g;\n    greedy.lastIndex = lastIndex;\n    return greedy.exec(password);\n  }\n\n  getLazyMatch(password, lastIndex) {\n    const lazy = /(.+?)\\1+/g;\n    lazy.lastIndex = lastIndex;\n    return lazy.exec(password);\n  }\n\n  setMatchToken(greedyMatch, lazyMatch) {\n    const lazyAnchored = /^(.+?)\\1+$/;\n    let match;\n    let baseToken = '';\n\n    if (lazyMatch && greedyMatch[0].length > lazyMatch[0].length) {\n      // greedy beats lazy for 'aabaab'\n      // greedy: [aabaab, aab]\n      // lazy:   [aa,     a]\n      match = greedyMatch; // greedy's repeated string might itself be repeated, eg.\n      // aabaab in aabaabaabaab.\n      // run an anchored lazy match on greedy's repeated string\n      // to find the shortest repeated string\n\n      const temp = lazyAnchored.exec(match[0]);\n\n      if (temp) {\n        baseToken = temp[1];\n      }\n    } else {\n      // lazy beats greedy for 'aaaaa'\n      // greedy: [aaaa,  aa]\n      // lazy:   [aaaaa, a]\n      match = lazyMatch;\n\n      if (match) {\n        baseToken = match[1];\n      }\n    }\n\n    return {\n      match,\n      baseToken\n    };\n  }\n\n  getBaseGuesses(baseToken, omniMatch) {\n    const matches = omniMatch.match(baseToken);\n\n    if (matches instanceof Promise) {\n      return matches.then(resolvedMatches => {\n        const baseAnalysis = scoring.mostGuessableMatchSequence(baseToken, resolvedMatches);\n        return baseAnalysis.guesses;\n      });\n    }\n\n    const baseAnalysis = scoring.mostGuessableMatchSequence(baseToken, matches);\n    return baseAnalysis.guesses;\n  }\n\n}\n\nexport { MatchRepeat as default };\n//# sourceMappingURL=matching.esm.js.map\n","import { ALL_LOWER, ALL_UPPER, ALL_DIGIT } from '../../data/const.esm.js';\n\n/*\n *-------------------------------------------------------------------------------\n * sequences (abcdef) ------------------------------\n *-------------------------------------------------------------------------------\n */\n\nclass MatchSequence {\n  constructor() {\n    this.MAX_DELTA = 5;\n  } // eslint-disable-next-line max-statements\n\n\n  match({\n    password\n  }) {\n    /*\n     * Identifies sequences by looking for repeated differences in unicode codepoint.\n     * this allows skipping, such as 9753, and also matches some extended unicode sequences\n     * such as Greek and Cyrillic alphabets.\n     *\n     * for example, consider the input 'abcdb975zy'\n     *\n     * password: a   b   c   d   b    9   7   5   z   y\n     * index:    0   1   2   3   4    5   6   7   8   9\n     * delta:      1   1   1  -2  -41  -2  -2  69   1\n     *\n     * expected result:\n     * [(i, j, delta), ...] = [(0, 3, 1), (5, 7, -2), (8, 9, 1)]\n     */\n    const result = [];\n\n    if (password.length === 1) {\n      return [];\n    }\n\n    let i = 0;\n    let lastDelta = null;\n    const passwordLength = password.length;\n\n    for (let k = 1; k < passwordLength; k += 1) {\n      const delta = password.charCodeAt(k) - password.charCodeAt(k - 1);\n\n      if (lastDelta == null) {\n        lastDelta = delta;\n      }\n\n      if (delta !== lastDelta) {\n        const j = k - 1;\n        this.update({\n          i,\n          j,\n          delta: lastDelta,\n          password,\n          result\n        });\n        i = j;\n        lastDelta = delta;\n      }\n    }\n\n    this.update({\n      i,\n      j: passwordLength - 1,\n      delta: lastDelta,\n      password,\n      result\n    });\n    return result;\n  }\n\n  update({\n    i,\n    j,\n    delta,\n    password,\n    result\n  }) {\n    if (j - i > 1 || Math.abs(delta) === 1) {\n      const absoluteDelta = Math.abs(delta);\n\n      if (absoluteDelta > 0 && absoluteDelta <= this.MAX_DELTA) {\n        const token = password.slice(i, +j + 1 || 9e9);\n        const {\n          sequenceName,\n          sequenceSpace\n        } = this.getSequence(token);\n        return result.push({\n          pattern: 'sequence',\n          i,\n          j,\n          token: password.slice(i, +j + 1 || 9e9),\n          sequenceName,\n          sequenceSpace,\n          ascending: delta > 0\n        });\n      }\n    }\n\n    return null;\n  }\n\n  getSequence(token) {\n    // TODO conservatively stick with roman alphabet size.\n    //  (this could be improved)\n    let sequenceName = 'unicode';\n    let sequenceSpace = 26;\n\n    if (ALL_LOWER.test(token)) {\n      sequenceName = 'lower';\n      sequenceSpace = 26;\n    } else if (ALL_UPPER.test(token)) {\n      sequenceName = 'upper';\n      sequenceSpace = 26;\n    } else if (ALL_DIGIT.test(token)) {\n      sequenceName = 'digits';\n      sequenceSpace = 10;\n    }\n\n    return {\n      sequenceName,\n      sequenceSpace\n    };\n  }\n\n}\n\nexport { MatchSequence as default };\n//# sourceMappingURL=matching.esm.js.map\n","import { extend, sorted } from '../../helper.esm.js';\nimport Options from '../../Options.esm.js';\n\n/*\n * ------------------------------------------------------------------------------\n * spatial match (qwerty/dvorak/keypad and so on) -----------------------------------------\n * ------------------------------------------------------------------------------\n */\n\nclass MatchSpatial {\n  constructor() {\n    this.SHIFTED_RX = /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/;\n  }\n\n  match({\n    password\n  }) {\n    const matches = [];\n    Object.keys(Options.graphs).forEach(graphName => {\n      const graph = Options.graphs[graphName];\n      extend(matches, this.helper(password, graph, graphName));\n    });\n    return sorted(matches);\n  }\n\n  checkIfShifted(graphName, password, index) {\n    if (!graphName.includes('keypad') && // initial character is shifted\n    this.SHIFTED_RX.test(password.charAt(index))) {\n      return 1;\n    }\n\n    return 0;\n  } // eslint-disable-next-line complexity, max-statements\n\n\n  helper(password, graph, graphName) {\n    let shiftedCount;\n    const matches = [];\n    let i = 0;\n    const passwordLength = password.length;\n\n    while (i < passwordLength - 1) {\n      let j = i + 1;\n      let lastDirection = 0;\n      let turns = 0;\n      shiftedCount = this.checkIfShifted(graphName, password, i); // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        const prevChar = password.charAt(j - 1);\n        const adjacents = graph[prevChar] || [];\n        let found = false;\n        let foundDirection = -1;\n        let curDirection = -1; // consider growing pattern by one character if j hasn't gone over the edge.\n\n        if (j < passwordLength) {\n          const curChar = password.charAt(j);\n          const adjacentsLength = adjacents.length;\n\n          for (let k = 0; k < adjacentsLength; k += 1) {\n            const adjacent = adjacents[k];\n            curDirection += 1; // eslint-disable-next-line max-depth\n\n            if (adjacent) {\n              const adjacentIndex = adjacent.indexOf(curChar); // eslint-disable-next-line max-depth\n\n              if (adjacentIndex !== -1) {\n                found = true;\n                foundDirection = curDirection; // eslint-disable-next-line max-depth\n\n                if (adjacentIndex === 1) {\n                  // # index 1 in the adjacency means the key is shifted,\n                  // # 0 means unshifted: A vs a, % vs 5, etc.\n                  // # for example, 'q' is adjacent to the entry '2@'.\n                  // # @ is shifted w/ index 1, 2 is unshifted.\n                  shiftedCount += 1;\n                } // eslint-disable-next-line max-depth\n\n\n                if (lastDirection !== foundDirection) {\n                  // # adding a turn is correct even in the initial\n                  // case when last_direction is null:\n                  // # every spatial pattern starts with a turn.\n                  turns += 1;\n                  lastDirection = foundDirection;\n                }\n\n                break;\n              }\n            }\n          }\n        } // if the current pattern continued, extend j and try to grow again\n\n\n        if (found) {\n          j += 1; // otherwise push the pattern discovered so far, if any...\n        } else {\n          // don't consider length 1 or 2 chains.\n          if (j - i > 2) {\n            matches.push({\n              pattern: 'spatial',\n              i,\n              j: j - 1,\n              token: password.slice(i, j),\n              graph: graphName,\n              turns,\n              shiftedCount\n            });\n          } // ...and then start a new search for the rest of the password.\n\n\n          i = j;\n          break;\n        }\n      }\n    }\n\n    return matches;\n  }\n\n}\n\nexport { MatchSpatial as default };\n//# sourceMappingURL=matching.esm.js.map\n","import { extend, sorted } from './helper.esm.js';\nimport MatchDate from './matcher/date/matching.esm.js';\nimport MatchDictionary from './matcher/dictionary/matching.esm.js';\nimport MatchRegex from './matcher/regex/matching.esm.js';\nimport MatchRepeat from './matcher/repeat/matching.esm.js';\nimport MatchSequence from './matcher/sequence/matching.esm.js';\nimport MatchSpatial from './matcher/spatial/matching.esm.js';\nimport Options from './Options.esm.js';\n\nclass Matching {\n  constructor() {\n    this.matchers = {\n      date: MatchDate,\n      dictionary: MatchDictionary,\n      regex: MatchRegex,\n      // @ts-ignore => TODO resolve this type issue. This is because it is possible to be async\n      repeat: MatchRepeat,\n      sequence: MatchSequence,\n      spatial: MatchSpatial\n    };\n  }\n\n  match(password) {\n    const matches = [];\n    const promises = [];\n    const matchers = [...Object.keys(this.matchers), ...Object.keys(Options.matchers)];\n    matchers.forEach(key => {\n      if (!this.matchers[key] && !Options.matchers[key]) {\n        return;\n      }\n\n      const Matcher = this.matchers[key] ? this.matchers[key] : Options.matchers[key].Matching;\n      const usedMatcher = new Matcher();\n      const result = usedMatcher.match({\n        password,\n        omniMatch: this\n      });\n\n      if (result instanceof Promise) {\n        result.then(response => {\n          extend(matches, response);\n        });\n        promises.push(result);\n      } else {\n        extend(matches, result);\n      }\n    });\n\n    if (promises.length > 0) {\n      return new Promise(resolve => {\n        Promise.all(promises).then(() => {\n          resolve(sorted(matches));\n        });\n      });\n    }\n\n    return sorted(matches);\n  }\n\n}\n\nexport { Matching as default };\n//# sourceMappingURL=Matching.esm.js.map\n","import Options from './Options.esm.js';\n\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst MONTH = DAY * 31;\nconst YEAR = MONTH * 12;\nconst CENTURY = YEAR * 100;\nconst times = {\n  second: SECOND,\n  minute: MINUTE,\n  hour: HOUR,\n  day: DAY,\n  month: MONTH,\n  year: YEAR,\n  century: CENTURY\n};\n/*\n * -------------------------------------------------------------------------------\n *  Estimates time for an attacker ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\n\nclass TimeEstimates {\n  translate(displayStr, value) {\n    let key = displayStr;\n\n    if (value !== undefined && value !== 1) {\n      key += 's';\n    }\n\n    const {\n      timeEstimation\n    } = Options.translations;\n    return timeEstimation[key].replace('{base}', `${value}`);\n  }\n\n  estimateAttackTimes(guesses) {\n    const crackTimesSeconds = {\n      onlineThrottling100PerHour: guesses / (100 / 3600),\n      onlineNoThrottling10PerSecond: guesses / 10,\n      offlineSlowHashing1e4PerSecond: guesses / 1e4,\n      offlineFastHashing1e10PerSecond: guesses / 1e10\n    };\n    const crackTimesDisplay = {\n      onlineThrottling100PerHour: '',\n      onlineNoThrottling10PerSecond: '',\n      offlineSlowHashing1e4PerSecond: '',\n      offlineFastHashing1e10PerSecond: ''\n    };\n    Object.keys(crackTimesSeconds).forEach(scenario => {\n      const seconds = crackTimesSeconds[scenario];\n      crackTimesDisplay[scenario] = this.displayTime(seconds);\n    });\n    return {\n      crackTimesSeconds,\n      crackTimesDisplay,\n      score: this.guessesToScore(guesses)\n    };\n  }\n\n  guessesToScore(guesses) {\n    const DELTA = 5;\n\n    if (guesses < 1e3 + DELTA) {\n      // risky password: \"too guessable\"\n      return 0;\n    }\n\n    if (guesses < 1e6 + DELTA) {\n      // modest protection from throttled online attacks: \"very guessable\"\n      return 1;\n    }\n\n    if (guesses < 1e8 + DELTA) {\n      // modest protection from unthrottled online attacks: \"somewhat guessable\"\n      return 2;\n    }\n\n    if (guesses < 1e10 + DELTA) {\n      // modest protection from offline attacks: \"safely unguessable\"\n      // assuming a salted, slow hash function like bcrypt, scrypt, PBKDF2, argon, etc\n      return 3;\n    } // strong protection from offline attacks under same scenario: \"very unguessable\"\n\n\n    return 4;\n  }\n\n  displayTime(seconds) {\n    let displayStr = 'centuries';\n    let base;\n    const timeKeys = Object.keys(times);\n    const foundIndex = timeKeys.findIndex(time => seconds < times[time]);\n\n    if (foundIndex > -1) {\n      displayStr = timeKeys[foundIndex - 1];\n\n      if (foundIndex !== 0) {\n        base = Math.round(seconds / times[displayStr]);\n      } else {\n        displayStr = 'ltSecond';\n      }\n    }\n\n    return this.translate(displayStr, base);\n  }\n\n}\n\nexport { TimeEstimates as default };\n//# sourceMappingURL=TimeEstimates.esm.js.map\n","var bruteforceMatcher = (() => {\n  return null;\n});\n\nexport { bruteforceMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import Options from '../../Options.esm.js';\n\nvar dateMatcher = (() => {\n  return {\n    warning: Options.translations.warnings.dates,\n    suggestions: [Options.translations.suggestions.dates]\n  };\n});\n\nexport { dateMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import Options from '../../Options.esm.js';\nimport { START_UPPER, ALL_UPPER_INVERTED } from '../../data/const.esm.js';\n\nconst getDictionaryWarningPassword = (match, isSoleMatch) => {\n  let warning = '';\n\n  if (isSoleMatch && !match.l33t && !match.reversed) {\n    if (match.rank <= 10) {\n      warning = Options.translations.warnings.topTen;\n    } else if (match.rank <= 100) {\n      warning = Options.translations.warnings.topHundred;\n    } else {\n      warning = Options.translations.warnings.common;\n    }\n  } else if (match.guessesLog10 <= 4) {\n    warning = Options.translations.warnings.similarToCommon;\n  }\n\n  return warning;\n};\n\nconst getDictionaryWarningWikipedia = (match, isSoleMatch) => {\n  let warning = '';\n\n  if (isSoleMatch) {\n    warning = Options.translations.warnings.wordByItself;\n  }\n\n  return warning;\n};\n\nconst getDictionaryWarningNames = (match, isSoleMatch) => {\n  if (isSoleMatch) {\n    return Options.translations.warnings.namesByThemselves;\n  }\n\n  return Options.translations.warnings.commonNames;\n};\n\nconst getDictionaryWarning = (match, isSoleMatch) => {\n  let warning = '';\n  const dictName = match.dictionaryName;\n  const isAName = dictName === 'lastnames' || dictName.toLowerCase().includes('firstnames');\n\n  if (dictName === 'passwords') {\n    warning = getDictionaryWarningPassword(match, isSoleMatch);\n  } else if (dictName.includes('wikipedia')) {\n    warning = getDictionaryWarningWikipedia(match, isSoleMatch);\n  } else if (isAName) {\n    warning = getDictionaryWarningNames(match, isSoleMatch);\n  } else if (dictName === 'userInputs') {\n    warning = Options.translations.warnings.userInputs;\n  }\n\n  return warning;\n};\n\nvar dictionaryMatcher = ((match, isSoleMatch) => {\n  const warning = getDictionaryWarning(match, isSoleMatch);\n  const suggestions = [];\n  const word = match.token;\n\n  if (word.match(START_UPPER)) {\n    suggestions.push(Options.translations.suggestions.capitalization);\n  } else if (word.match(ALL_UPPER_INVERTED) && word.toLowerCase() !== word) {\n    suggestions.push(Options.translations.suggestions.allUppercase);\n  }\n\n  if (match.reversed && match.token.length >= 4) {\n    suggestions.push(Options.translations.suggestions.reverseWords);\n  }\n\n  if (match.l33t) {\n    suggestions.push(Options.translations.suggestions.l33t);\n  }\n\n  return {\n    warning,\n    suggestions\n  };\n});\n\nexport { dictionaryMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import Options from '../../Options.esm.js';\n\nvar regexMatcher = (match => {\n  if (match.regexName === 'recentYear') {\n    return {\n      warning: Options.translations.warnings.recentYears,\n      suggestions: [Options.translations.suggestions.recentYears, Options.translations.suggestions.associatedYears]\n    };\n  }\n\n  return {\n    warning: '',\n    suggestions: []\n  };\n});\n\nexport { regexMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import Options from '../../Options.esm.js';\n\nvar repeatMatcher = (match => {\n  let warning = Options.translations.warnings.extendedRepeat;\n\n  if (match.baseToken.length === 1) {\n    warning = Options.translations.warnings.simpleRepeat;\n  }\n\n  return {\n    warning,\n    suggestions: [Options.translations.suggestions.repeated]\n  };\n});\n\nexport { repeatMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import Options from '../../Options.esm.js';\n\nvar sequenceMatcher = (() => {\n  return {\n    warning: Options.translations.warnings.sequences,\n    suggestions: [Options.translations.suggestions.sequences]\n  };\n});\n\nexport { sequenceMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import Options from '../../Options.esm.js';\n\nvar spatialMatcher = (match => {\n  let warning = Options.translations.warnings.keyPattern;\n\n  if (match.turns === 1) {\n    warning = Options.translations.warnings.straightRow;\n  }\n\n  return {\n    warning,\n    suggestions: [Options.translations.suggestions.longerKeyboardPattern]\n  };\n});\n\nexport { spatialMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import Options from './Options.esm.js';\nimport bruteforceMatcher from './matcher/bruteforce/feedback.esm.js';\nimport dateMatcher from './matcher/date/feedback.esm.js';\nimport dictionaryMatcher from './matcher/dictionary/feedback.esm.js';\nimport regexMatcher from './matcher/regex/feedback.esm.js';\nimport repeatMatcher from './matcher/repeat/feedback.esm.js';\nimport sequenceMatcher from './matcher/sequence/feedback.esm.js';\nimport spatialMatcher from './matcher/spatial/feedback.esm.js';\n\nconst defaultFeedback = {\n  warning: '',\n  suggestions: []\n};\n/*\n * -------------------------------------------------------------------------------\n *  Generate feedback ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\n\nclass Feedback {\n  constructor() {\n    this.matchers = {\n      bruteforce: bruteforceMatcher,\n      date: dateMatcher,\n      dictionary: dictionaryMatcher,\n      regex: regexMatcher,\n      repeat: repeatMatcher,\n      sequence: sequenceMatcher,\n      spatial: spatialMatcher\n    };\n    this.defaultFeedback = {\n      warning: '',\n      suggestions: []\n    };\n    this.setDefaultSuggestions();\n  }\n\n  setDefaultSuggestions() {\n    this.defaultFeedback.suggestions.push(Options.translations.suggestions.useWords, Options.translations.suggestions.noNeed);\n  }\n\n  getFeedback(score, sequence) {\n    if (sequence.length === 0) {\n      return this.defaultFeedback;\n    }\n\n    if (score > 2) {\n      return defaultFeedback;\n    }\n\n    const extraFeedback = Options.translations.suggestions.anotherWord;\n    const longestMatch = this.getLongestMatch(sequence);\n    let feedback = this.getMatchFeedback(longestMatch, sequence.length === 1);\n\n    if (feedback !== null && feedback !== undefined) {\n      feedback.suggestions.unshift(extraFeedback);\n\n      if (feedback.warning == null) {\n        feedback.warning = '';\n      }\n    } else {\n      feedback = {\n        warning: '',\n        suggestions: [extraFeedback]\n      };\n    }\n\n    return feedback;\n  }\n\n  getLongestMatch(sequence) {\n    let longestMatch = sequence[0];\n    const slicedSequence = sequence.slice(1);\n    slicedSequence.forEach(match => {\n      if (match.token.length > longestMatch.token.length) {\n        longestMatch = match;\n      }\n    });\n    return longestMatch;\n  }\n\n  getMatchFeedback(match, isSoleMatch) {\n    if (this.matchers[match.pattern]) {\n      return this.matchers[match.pattern](match, isSoleMatch);\n    }\n\n    if (Options.matchers[match.pattern] && 'feedback' in Options.matchers[match.pattern]) {\n      return Options.matchers[match.pattern].feedback(match, isSoleMatch);\n    }\n\n    return defaultFeedback;\n  }\n\n}\n\nexport { Feedback as default };\n//# sourceMappingURL=Feedback.esm.js.map\n","import Matching from './Matching.esm.js';\nimport scoring from './scoring/index.esm.js';\nimport TimeEstimates from './TimeEstimates.esm.js';\nimport Feedback from './Feedback.esm.js';\nimport Options from './Options.esm.js';\nexport { default as ZxcvbnOptions } from './Options.esm.js';\n\nconst time = () => new Date().getTime();\n\nconst createReturnValue = (resolvedMatches, password, start) => {\n  const feedback = new Feedback();\n  const timeEstimates = new TimeEstimates();\n  const matchSequence = scoring.mostGuessableMatchSequence(password, resolvedMatches);\n  const calcTime = time() - start;\n  const attackTimes = timeEstimates.estimateAttackTimes(matchSequence.guesses);\n  return {\n    calcTime,\n    ...matchSequence,\n    ...attackTimes,\n    feedback: feedback.getFeedback(attackTimes.score, matchSequence.sequence)\n  };\n};\n\nconst zxcvbn = (password, userInputs) => {\n  if (userInputs) {\n    Options.extendUserInputsDictionary(userInputs);\n  }\n\n  const matching = new Matching();\n  const start = time();\n  const matches = matching.match(password);\n\n  if (matches instanceof Promise) {\n    return matches.then(resolvedMatches => {\n      return createReturnValue(resolvedMatches, password, start);\n    });\n  }\n\n  return createReturnValue(matches, password, start);\n};\n\nexport { zxcvbn };\n//# sourceMappingURL=index.esm.js.map\n","/*\n * This file is part of glowingblue/password-strength.\n *\n * Copyright (c) 2021 Rafael Horvat.\n *\n * For the full copyright and license information, please view the LICENSE.md\n * file that was distributed with this source code.\n */\n\nimport Component from 'flarum/common/Component';\n\nexport default class StrengthIndicator extends Component {\n\toninit(vnode) {\n\t\tsuper.oninit(vnode);\n\t}\n\n\tview() {\n\t\tconst { label, color } = this.attrs;\n\t\treturn (\n\t\t\t<div className={`StrengthIndicator ${label ? 'active' : ''}`}>\n\t\t\t\t<div className='StrengthIndicator-container'>\n\t\t\t\t\t<div className='StrengthIndicator-pills'>\n\t\t\t\t\t\t{['weak', 'medium', 'strong'].map((key) => (\n\t\t\t\t\t\t\t<StrengthPill color={color} active={this.isPillActive(key)} />\n\t\t\t\t\t\t))}\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className='StrengthIndicator-label'>\n\t\t\t\t\t\t<span>{label}</span>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n\n\tisPillActive(key) {\n\t\tconst { score } = this.attrs;\n\t\tswitch (key) {\n\t\t\tcase 'weak':\n\t\t\t\tif (Number.isInteger(score)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\tcase 'medium':\n\t\t\t\tif (score >= 2) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\tcase 'strong':\n\t\t\t\tif (score >= 4) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n}\n\nclass StrengthPill extends Component {\n\tview() {\n\t\tconst { color, active } = this.attrs;\n\t\tconst backgroundColor = active ? color : undefined;\n\t\treturn <div className='StrengthPill' style={{ backgroundColor }}></div>;\n\t}\n}\n","/*\n * This file is part of glowingblue/password-strength.\n *\n * Copyright (c) 2021 Rafael Horvat.\n *\n * For the full copyright and license information, please view the LICENSE.md\n * file that was distributed with this source code.\n */\n\nimport Component from 'flarum/common/Component';\nimport Stream from 'flarum/common/utils/Stream';\nimport extractText from 'flarum/common/utils/extractText';\nimport { zxcvbn } from '@zxcvbn-ts/core';\nimport EyeButton from './EyeButton';\nimport StrengthIndicator from './StrengthIndicator';\nimport { slug } from '../../common';\n\n// Make translation calls shorter\nconst t = app.translator.trans.bind(app.translator);\nconst prfx = `${slug}.forum.strengthLabels`;\n// Make settings accessible easier\nconst settings = (key) => app.forum.attribute(`${slug}.${key}`);\n\nexport default class SignUpPasswordField extends Component {\n\toninit(vnode) {\n\t\tsuper.oninit(vnode);\n\n\t\tthis.strengthLabel = new Stream('');\n\t\tthis.passwordScore = new Stream(undefined);\n\t\tthis.strengthColor = new Stream('');\n\t}\n\n\tview() {\n\t\tconst { parent_this, showingPassword, hasConfirmFiled, isConfirmFiled } = this.attrs;\n\n\t\treturn (\n\t\t\t// This markup is copied from `flarum/components/LogInModal` and then\n\t\t\t// some things have been added.\n\t\t\t// !!! Please check for updates regularly !!!\n\n\t\t\t<div className='Form-group PasswordField'>\n\t\t\t\t<input\n\t\t\t\t\tclassName={`FormControl ${settings('enablePasswordToggle') ? 'togglable' : ''}`}\n\t\t\t\t\tname={isConfirmFiled ? 'confirmPassword' : 'password'}\n\t\t\t\t\ttype={showingPassword() ? 'text' : 'password'}\n\t\t\t\t\tplaceholder={\n\t\t\t\t\t\tisConfirmFiled\n\t\t\t\t\t\t\t? t('nearata-signup-confirm-password.forum.field_placeholder')\n\t\t\t\t\t\t\t: extractText(t('core.forum.sign_up.password_placeholder'))\n\t\t\t\t\t}\n\t\t\t\t\tvalue={isConfirmFiled ? parent_this.confirmPassword() : parent_this.password()}\n\t\t\t\t\tdisabled={parent_this.loading}\n\t\t\t\t\toninput={this.inputHandler.bind(this)}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tcolor:\n\t\t\t\t\t\t\tsettings('enableInputColor') &&\n\t\t\t\t\t\t\t!showingPassword() &&\n\t\t\t\t\t\t\t(!hasConfirmFiled || isConfirmFiled)\n\t\t\t\t\t\t\t\t? this.strengthColor()\n\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\tborderColor:\n\t\t\t\t\t\t\tsettings('enableInputBorderColor') &&\n\t\t\t\t\t\t\t(!hasConfirmFiled || isConfirmFiled)\n\t\t\t\t\t\t\t\t? this.strengthColor()\n\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t}}\n\t\t\t\t/>\n\n\t\t\t\t{settings('enablePasswordToggle') ? <EyeButton showing={showingPassword} /> : null}\n\n\t\t\t\t{!hasConfirmFiled || isConfirmFiled ? (\n\t\t\t\t\t<StrengthIndicator\n\t\t\t\t\t\tscore={this.passwordScore()}\n\t\t\t\t\t\tlabel={this.strengthLabel()}\n\t\t\t\t\t\tcolor={this.strengthColor()}\n\t\t\t\t\t/>\n\t\t\t\t) : null}\n\t\t\t</div>\n\t\t);\n\t}\n\n\tinputHandler(e) {\n\t\tconst { parent_this, isConfirmFiled } = this.attrs;\n\n\t\tconst password = e.target.value;\n\n\t\tif (isConfirmFiled) {\n\t\t\tparent_this.confirmPassword(password);\n\t\t} else {\n\t\t\tparent_this.password(password);\n\t\t}\n\n\t\tif (password) {\n\t\t\t// Get the score of the password strength\n\t\t\tlet { score } = zxcvbn(password);\n\t\t\tthis.passwordScore(score);\n\n\t\t\t// Define strength color & label\n\t\t\tswitch (score) {\n\t\t\t\tcase 0:\n\t\t\t\tcase 1:\n\t\t\t\t\tthis.strengthLabel(t(`${prfx}.weak`));\n\t\t\t\t\tthis.strengthColor(`rgb(${settings('weakColor')})`);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tthis.strengthLabel(t(`${prfx}.medium`));\n\t\t\t\t\tthis.strengthColor(`rgb(${settings('mediumColor')})`);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tthis.strengthLabel(t(`${prfx}.strong`));\n\t\t\t\t\tthis.strengthColor(`rgb(${settings('strongColor')})`);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.passwordScore(undefined);\n\t\t\tthis.strengthLabel('');\n\t\t\tthis.strengthColor(undefined);\n\t\t}\n\t}\n}\n","/*\n * This file is part of glowingblue/password-strength.\n *\n * Copyright (c) 2021 Rafael Horvat.\n *\n * For the full copyright and license information, please view the LICENSE.md\n * file that was distributed with this source code.\n */\n\nimport app from 'flarum/common/app';\nimport { extend } from 'flarum/common/extend';\nimport LogInModal from 'flarum/forum/components/LogInModal';\nimport SignUpModal from 'flarum/forum/components/SignUpModal';\nimport Stream from 'flarum/common/utils/Stream';\nimport { slug } from '../common';\nimport LogInPasswordField from './components/LogInPasswordField';\nimport SignUpPasswordField from './components/SignUpPasswordField';\n\napp.initializers.add(slug, () => {\n\tfunction extendOninit() {\n\t\tthis.showingPassword = new Stream(false);\n\t}\n\textend(LogInModal.prototype, 'oninit', extendOninit);\n\textend(SignUpModal.prototype, 'oninit', extendOninit);\n\n\textend(LogInModal.prototype, 'fields', function (items) {\n\t\tif (app.forum.attribute(`${slug}.enablePasswordToggle`)) {\n\t\t\titems.setContent(\n\t\t\t\t'password',\n\t\t\t\t<LogInPasswordField\n\t\t\t\t\tparent_this={this}\n\t\t\t\t\tshowingPassword={this.showingPassword.bind(this)}\n\t\t\t\t/>,\n\t\t\t);\n\t\t}\n\t});\n\n\textend(SignUpModal.prototype, 'fields', function (items) {\n\t\tif (!this.attrs.token) {\n\t\t\tconst hasConfirmFiled =\n\t\t\t\titems.has('nearataConfirmPassword') && this.confirmPassword !== undefined;\n\n\t\t\titems.setContent(\n\t\t\t\t'password',\n\t\t\t\t<SignUpPasswordField\n\t\t\t\t\tparent_this={this}\n\t\t\t\t\tshowingPassword={this.showingPassword.bind(this)}\n\t\t\t\t\thasConfirmFiled={hasConfirmFiled}\n\t\t\t\t/>,\n\t\t\t);\n\n\t\t\tif (hasConfirmFiled) {\n\t\t\t\titems.setContent(\n\t\t\t\t\t'nearataConfirmPassword',\n\t\t\t\t\t<SignUpPasswordField\n\t\t\t\t\t\tparent_this={this}\n\t\t\t\t\t\tshowingPassword={this.showingPassword.bind(this)}\n\t\t\t\t\t\thasConfirmFiled={hasConfirmFiled}\n\t\t\t\t\t\tisConfirmFiled={true}\n\t\t\t\t\t/>,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t});\n});\n"],"names":["__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","flarum","core","compat","slug","_setPrototypeOf","p","setPrototypeOf","__proto__","_inheritsLoose","subClass","superClass","create","constructor","EyeButton","oninit","vnode","view","showing","this","attrs","className","onclick","icon","Component","t","app","translator","trans","bind","LogInPasswordField","parent_this","showingPassword","name","type","placeholder","extractText","bidi","password","disabled","loading","_extends","assign","target","i","arguments","length","source","apply","extend","listToExtend","sorted","matches","m1","m2","buildRankedDictionary","orderedList","result","counter","word","DATE_SPLITS","START_UPPER","END_UPPER","ALL_UPPER","ALL_UPPER_INVERTED","ALL_LOWER","ALL_LOWER_INVERTED","ONE_UPPER","ONE_LOWER","ALPHA_INVERTED","ALL_DIGIT","REFERENCE_YEAR","REGEXEN","recentYear","match","filteredMatches","getMatchesWithSeparator","maybeDateWithSeparator","Math","j","token","regexMatch","dmy","parseInt","pattern","separator","year","month","day","getMatchesWithoutSeparator","maybeDateNoSeparator","metric","candidate","candidates","index","splittedDates","bestCandidate","minDistance","distance","filterNoise","isSubmatch","matchesLength","otherMatch","mapIntegersToDayMonthYear","integers","over12","over31","under1","len1","int","getDayMonth","possibleYearSplits","possibleYearSplitsLength","DATE_MIN_YEAR","y","dm","k","mapIntegersToDayMonth","temp","data","twoToFourDigitYear","l33tTable","b","c","e","g","l","s","x","z","translationKeys","warnings","straightRow","keyPattern","simpleRepeat","extendedRepeat","sequences","recentYears","dates","topTen","topHundred","common","similarToCommon","wordByItself","namesByThemselves","commonNames","userInputs","suggestions","l33t","reverseWords","allUppercase","capitalization","associatedYears","repeated","longerKeyboardPattern","anotherWord","useWords","noNeed","timeEstimation","ltSecond","second","seconds","minute","minutes","hour","hours","days","months","years","centuries","setOptions","options","setTranslations","checkCustomTranslations","valid","translationType","translations","setRankedDictionaries","rankedDictionaries","getRankedDictionary","list","sanitizedInputs","input","inputType","extendUserInputsDictionary","addMatcher","console","defaultMatch","passwordReversed","reversed","enumeratedSubs","Options","sub","subbedPassword","string","tempArray","char","chrMap","matchedDictionary","matchSub","subbedChr","chr","subDisplay","relevantL33tSubtable","passwordChars","subTable","letter","relevantSubs","table","subs","enumerateL33tSubs","tableKeys","subDict","getSubs","keys","firstKey","restKeys","nextSubs","l33tChr","dupL33tIndex","subExtension","subAlternative","newSubs","dedup","deduped","members","assoc","label","passwordLength","passwordLower","dictionaryName","rankedDict","rank","matchedWord","regexes","regex","regexName","utils","count","coEff","matchers","bruteforce","guesses","Number","minGuesses","MIN_SUBMATCH_GUESSES_SINGLE_CHAR","MIN_SUBMATCH_GUESSES_MULTI_CHAR","date","dictionary","baseGuesses","uppercaseVariations","cleanedWord","commonCases","commonCasesLength","wordArray","upperCaseCount","lowerCaseCount","variations","variationLength","getVariations","uppercaseVariant","l33tVariations","subbed","unsubbed","chrs","subbedCount","unsubbedCount","getCounts","possibilities","l33tVariant","calculation","charClassBases","alphaLower","alphaUpper","alpha","alphanumeric","digits","symbols","repeat","repeatCount","sequence","ascending","firstChr","startingPoints","spatial","turns","startingPosition","averageDegree","graph","average","neighbors","entry","calcAverageDegree","tokenLength","possibleTurns","estimatePossiblePatterns","shiftedCount","unShiftedCount","shiftedVariations","scoringHelper","optimal","excludeAdditive","fillArray","valueType","makeBruteforceMatch","update","estimatedMatch","extraData","getMinGuesses","estimationResult","getScoring","matchGuesses","guessesLog10","estimateGuesses","pi","sequenceLength","rval","shouldSkip","competingPatternLength","competingMetricMatch","bruteforceUpdate","tmp","lastMatch","unwind","optimalMatchSequence","candidateSequenceLength","candidateMetricMatch","mostGuessableMatchSequence","matchesByCoordinateJ","m","optimalSequenceLength","getGuesses","omniMatch","lastIndex","greedyMatch","lazyMatch","baseToken","hasPromises","Promise","normalizeMatch","baseMatch","resolvedBaseGuesses","getGreedyMatch","greedy","getLazyMatch","lazy","setMatchToken","lazyAnchored","getBaseGuesses","resolvedMatches","scoring","lastDelta","delta","absoluteDelta","sequenceSpace","sequenceName","getSequence","graphName","checkIfShifted","helper","lastDirection","adjacents","found","foundDirection","curDirection","curChar","adjacentsLength","adjacent","adjacentIndex","spatialMatcher","promises","response","resolve","times","SECOND","MINUTE","HOUR","DAY","MONTH","century","YEAR","translate","estimateAttackTimes","crackTimesSeconds","onlineThrottling100PerHour","onlineNoThrottling10PerSecond","offlineSlowHashing1e4PerSecond","offlineFastHashing1e10PerSecond","crackTimesDisplay","scenario","score","guessesToScore","displayTime","displayStr","timeKeys","foundIndex","time","base","warning","dictName","isAName","isSoleMatch","getDictionaryWarningPassword","getDictionaryWarningWikipedia","getDictionaryWarningNames","getDictionaryWarning","defaultFeedback","setDefaultSuggestions","getFeedback","extraFeedback","longestMatch","feedback","getLongestMatch","slicedSequence","getMatchFeedback","Date","createReturnValue","start","timeEstimates","matchSequence","calcTime","attackTimes","StrengthIndicator","color","map","StrengthPill","active","isPillActive","isInteger","style","backgroundColor","undefined","prfx","settings","forum","attribute","SignUpPasswordField","strengthLabel","Stream","passwordScore","strengthColor","hasConfirmFiled","isConfirmFiled","confirmPassword","oninput","inputHandler","borderColor","matching","zxcvbn","extendOninit","LogInModal","SignUpModal","items","setContent","has"],"sourceRoot":""}